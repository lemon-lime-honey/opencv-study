# 이미지 프로세싱

## 01 색상 공간 변환

- Color Space Transformation
- 색상 공간(Color Space)
  - 이미지에서 색상을 표현하는 방법
  - 각각의 색상 공간마다 특정 작업을 수행하기 위한 색상 표현 방식이 존재
  - RGB, HSV, Lav, YUV 등
- OpenCV의 색상 공간 변환 함수는 데이터 형식을 유지하면서 이미지의 채널 변환
  - 입력된 이미지는 8비트, 16비트, 32비트의 정밀도를 갖는 배열을 사용할 수 있음
  - 출력된 이미지: 입력된 이미지의 이미지 크기와 정밀도가 동일한 배열
  - 채널의 수가 감소하게 되면...
    - 이미지 내부의 데이터는 설정한 색상 공간과 일치하는 값으로 변환됨
    - 데이터 값이 변경되거나 채널 순서가 변경될 수 있음
- 색상 공간 변환 함수
  - C#

    ```csharp
    Cv2.CvtColor(
        Mat src,
        Mat dst,
        ColorConversionCodes code,
        int dstCn = 0
    );
    ```

  - Python

    ```python
    dst = cv2.cvtColor(
        src,
        code,
        dstCn=None
    )
    ```

  - 입력 이미지(`src`)에 색상 변환 코드(`code`)를 적용해 출력 이미지(`dst`)로 반환함
    - 색상 변환 코드(`code`)를 사용해...
      - BGR 색상 공간을 RBGA 색상 공간으로 변환
      - 그레이스케일, HSV, CIE Luv 등 단일 채널부터 3채널, 4채널의 색상 공간으로도 변환 가능
      - 채널의 수가 동일해도 BGR 색상 공간과 HSV 색상 공간 등은 명확히 표현 색상이 다르므로 데이터의 변형이 일어남
  - 출력 채널(`dstCn`): 출력 이미지(`dst`)에 필요한 채널 수 설정
    - `0`: 채널 수는 입력 배열과 색상 변환 코드에 의해 자동으로 결정됨
    - 일반적으로 값을 할당하지 않아 자동으로 채널의 수를 결정하게 함

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-1/Program.cs#L1-L20

- 색상 이미지를 그레이스케일 이미지로 변환하는 과정에서 사용하는 계산식  
  $` Y=0.299 \times R + 0.587 \times G + 0.114 \times B `$
  - `MatType.CV_8UC3`이 아닌 `MatType.CV_8UC1`의 형태로 사용
- `dst` 변수: 기본 생성자로 사용해도 무관
  - 명시적으로 이미지 크기, 정밀도, 채널을 선언해서 사용하는 것을 권장

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-2/Program.py#L1-L8

- HSV: Hue, Saturation, Value
- `cv2.imshow`: 기본적으로 BGR 색상 공간으로 표현

(표 5.1)

- 색상 변환 함수의 색상 변환 코드: **원본 이미지 색상 공간2결과 이미지 색상 공간** 패턴으로 색상 공간 코드를 조합함
  - `BayerBG`, `BayerGB`, `BayerRG`: Bayer 패턴
  - `_VNG`: 그라데이션 디모자이킹
  - `_EA`: 가장자리 인식 디모자이킹
  - `UYVY`: YUV 4:2:2
  - `mRGBA`: 알파 프리멀티플라이드
- 색상 공간 변환 함수는 이미지 크기와 정밀도를 유지하고 채널의 수만 변화하는 함수
  - 변환된 색상 공간의 픽셀 범위는 다음과 같은 규칙 사용
    - 8비트 이미지 색상 범위: 0 - 255
    - 16비트 이미지 색상 범위: 0 - 65,536
    - 32비트 이미지 색상 범위: 0.0 - 1.0
  - HSV, HLS의 Hue 값은 위의 규칙을 따르지 않음
    - 일반적으로 0 - 360 사이의 값으로 표현
    - 0 - 360 사이의 값으로 표현하려면 8비트 이미지가 입력되었을 때 16비트 이미지로 표현해야 함
    - 출력 이미지가 8비트일 때 Hue가 255를 넘어가면 문제 발생
    - Hue의 범위는 절반으로 나눈 값을 사용해 0 - 179의 범위로 사용
      - 180 이상의 값은 0부터 값이 증가
      - 255를 초과하는 값은 uint8 자료형으로 인해 다시 0부터 값 증가
  - Lab 색상 공간에서 L은 0 - 100, a와 b는 -127 - 127 범위이지만 OpenCV에서는 정규화하여 0 - 255로 표현

### 1. HSV 색상 공간

- Hue, Saturation, Value
  - Hue
    - 시각적 감각의 속성
    - 인간이 인식하는 색상 또는 범주
    - 원형 모델로 0˚에서 360˚까지의 값으로 표현됨
  - Saturation
    - 색상의 진함 또는 옅음
    - 채도가 높을수록 색은 더 진하고 선명하게 보임
    - 채도가 낮을수록 더 회색조로 표현
    - 0%에서 100%까지의 값을 가질 수 있음
    - 0%: 회색조(무채색), 100%: 가장 선명한 색상
  - Value
    - 색의 밝기
    - 0%: 검은색, 100%: 흰색, 중간값: 해당 색상의 일반적인 밝기
    - 명도가 높을수록 색상이 밝아짐
    - 명도가 낮을수록 색상이 어두워짐
- 이미지에서 특정 색상을 검출하고 분류하는 작업이 훨씬 간단해짐
- 색상을 인식하는 데 있어 인간의 시각 체계와 더 유사하게 구성됨
- OpenCV에서 HSV의 값을 설정할 때 각 속성의 최소값과 최대값
  - 색조: 0 - 180(최대값으로 할당 가능한 값: 179)
  - 채도: 0 - 255
  - 명도: 0 - 255
  - 채도와 명도는 선형의 기울기(Gradient) 형태로 최소와 최대 설정이 간편함
  - 색조의 경우 최소와 최대에서 빨간색 범위가 겹침
    - 색상 채널 분리 및 병합이 필요

### 2. 채널 분리 및 병합

- HSV 색상 공간의 경우
  - 색조 채널의 빨간색 채널을 검출하려면 낮은 각도의 빨간색 채널, 높은 각도의 빨간색 채널을 만든 후 합산
- 채널 분리 함수
  - C#

    ```csharp
    Mat[] mv = Cv2.split(
        Mat src
    );
    ```

  - Python

    ```python
    mv = cv2.split(
        src
      )
    ```

  - 다중 채널 입력 이미지(`src`)를 단일 채널 이미지 배열(`mv`)로 나눔
  - 3채널 이미지를 분리할 경우 단일 채널 이미지로 나눠져 세 개의 결과 이미지로 생성됨
  - `mv` 배열 안에는 첫 번째 채널(`mv[0]`), 두 번째 채널(`mv[1]`), 세 번째 채널(`mv[2]`)이 포함됨
- 채널 병합 함수
  - C#

    ```csharp
    Cv2.Merge(
        Mat[] mv,
        Mat dst
    );
    ```

  - Python

    ```python
    dst = cv2.merge(
        mv
      )
    ```

  - 이미지의 각 채널을 개별적으로 조작한 후 여러 채널을 결합해 다중 채널 이미지를 만들 수 있음
  - 단일 채널 이미지(`mv`)를 병합해 하나의 출력 이미지(`dst`)로 반환함
  - 채널 분리 함수와 반대로 작동
  - `mv` 배열 안에는 첫 번째 채널(`mv[0]`), 두 번째 채널(`mv[1]`), 세 번째 채널(`mv[2]`)이 포함되어야 함
  - `mv` 배열의 첫 번째 채널이 채널 병합의 기준이 되어 모든 채널의 속성이 첫 번째 채널의 속성과 일치해야 함
  - 속성: 이미지 크기, 정밀도
    - C#: `Mat[]` 클래스 배열 형태로 할당
    - Python: 리스트 또는 튜플
- 채널 분리 함수와 채널 병합 함수는 4채널 이미지까지 처리 가능
  - 4채널 이미지를 분리한다면 네 개의 단일 채널 이미지가 생성됨
  - 4채널 이미지를 만들기 위해 병합한다면 네 번째 채널(`mv[3]`) 추가
- 다중 채널 이미지에서 단일 채널을 갖는 이미지들로 분리했다면 해당 채널에서 특정 범위의 값으로 검출해야 함
  - 검출하려는 값과 일치하는 범위는 255 할당, 일치하지 않는 범위는 0 할당
  - 이때 배열 요소의 범위 설정 함수 사용
- 배열 요소 범위 설정 함수
  - C#

      ```csharp
      Cv2.InRange(
          Mat src,
          Scalar lowerb,
          Scalar upperb,
          Mat dst
      );
      ```

  - Python

    ```python
    dst = cv2.inRange(
        src,
        lowerb,
        upperb
    )
    ```

  - 입력 이미지(`src`)에서 낮은 범위(`lowerb`)에서 높은 범위(`upperb`) 사이의 요소 검출
  - 범위 안에...
    - 포함된다면 포함되는 값을 255로 변경
    - 포함되지 않는다면 0으로 변경
  - C#
    - 범위 설정 시 스칼라 구조체 사용
    - 단일 채널 이미지의 경우 `new Scalar(v)`의 형태로 할당
    - 다중 채널 이미지의 경우 `new Scalar(v0, v2, v2)` 등의 형식으로 할당
  - Python
    - 튜플로 범위 할당
    - 단일 채널 이미지의 경우 `int` 형식으로 `v` 값을 할당해 사용
    - 다중 채널 이미지의 경우 `(v0, v2, v2)` 형식으로 할당

### 3. 색상 검출

- HSV 색상 공간을 활용해 채널을 분리하고, 특정 색상의 상한 범위와 하한 범위를 설정해 색상 검출 수행 가능

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-3/Program.cs#L1-L27

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-4/Program.py#L1-L14

- 가중치 병합 함수
  - C#

    ```csharp
    Cv2.AddWeighted(
        Mat src1,
        double alpha,
        Mat src2,
        double beta,
        double gamma,
        Mat dst,
        int dtype = -1
    );
    ```

  - Python

    ```python
    dst = cv2.addWeighted(
        src1,
        alpha,
        src2,
        beta,
        gamma,
        dtype=None
    )
    ```

  - 입력 이미지1(`src1`)에 대한 가중치(`alpha`) 곱과 입력 이미지2(`src2`)에 대한 가중치(`beta`) 곱의 합 중 추가 합(`gamma`)을 더해 계산
  - 선택 깊이(`dtype`)는 정밀도를 임의로 설정 가능
    - 기본값을 사용할 경우 이미지1(`src1`)의 정밀도로 설정됨
  - 수식 5.1 가중치 병합 함수  
    $` \text{dst} = \text{src1} \times \text{alpha} `$
  - **알파 블렌딩(alpha blending)** 을 구현할 수 있어 서로 다른 이미지를 불투명하게 혼합해서 표시할 수 있음
    - 이미지 위에 다른 이미지를 덧씌워 투명하게 비치는 효과
  - 입력 이미지1(`src1`)과 입력 이미지2(`src2`)를 어떠한 변화 없이 사용할 경우
    - `alpha`: `1.0`, `beta`: `1.0`, `gamma`: `0.0`으로 할당
  - 출력 이미지(`dst`): 두 입력 이미지의 정밀도가 같으므로 기본값 사용

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-5/Program.cs#L1-L31

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-6/Program.py#L1-L17

(표 5.2)

(표 5.3)

## 02 이진화

- Binarization
- 픽셀 값의 연속적인 범위를 두 개의 클래스로 나누어 데이터를 단순화하는 과정
  - 이 두 개의 클래스는 일반적으로 검은색과 흰색으로 표현됨
- 이미지에서 특정 객체나 패턴을 감지하거나 이미지를 세분화하고 경계를 추출하는 데에 자주 사용됨
- 각 픽셀의 밝기 값을 기준을 두 클래스를 나누는데, 이를 위해 **임계값(Threshold)** 이라는 값을 설정함
  - 픽셀이 임계값보다 크면 A 클래스(보통 흰색)로 할당, 작으면 B 클래스로 할당
- 임계값을 기준으로 픽셀을 참 또는 거짓으로 나누는 연산
  - 이미지 행렬에서 모든 픽셀에 대해 이러한 연산 수행
- 이진화된 이미지를 통해 객체의 윤곽을 뚜렷하게 나타내거나 특정 패턴을 분리하는데 사용
- 이진화 함수
  - C#

    ```csharp
    Cv2.Threshold(
        Mat src,
        Mat dst,
        double thresh,
        double maxval,
        ThresholdTypes type
    );
    ```

  - Python

    ```python
    retval, dst = cv2.threshold(
        src,
        thresh,
        maxval,
        type
    )
    ```

  - **입력 이미지(`src`)** 에서 **임계값 형식(`type`)** 에 따라 특정한 비교 연산 진행
  - **임계값(`thresh`)** 보다 낮은 픽셀 값은 0이나 원본 픽셀 값으로 변경
  - **임계값(`thresh`)** 보다 높은 픽셀 값은 **최대값(`maxval`)** 으로 변경
  - 변형된 이미지는 **출력 이미지(`dst`)** 에 저장
  - Python OpenCV에서는 **설정 임계값(`retval`)** 도 반환
- 일반적으로 이진화 함수는 단일 채널 이미지에서 활용됨
- 다중 채널 이미지에 이진화 함수를 적용할 경우 각 채널을 분리해서 이진화 함수를 적용한 후 이미지를 다시 병합해 반환
- 특정 임계값 형식에서는 단일 채널 이미지만을 지원함

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-7/Program.cs#L1-L22

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-8/Program.py#L1-L8

- 이진화 함수는 임계값 형식에 OR 연산 적용 가능
  - 추가적인 이진화 알고리즘을 사용할 때에는 임계값과 최대값이 이진화 알고리즘에 적용될 수 있음
- 다중 채널 이미지에서 특정 작업을 수행하려면...
  - 각 채널을 개별적으로 나눠 이진화를 처리
  - 또는 채널 간에 정보를 조합하는 방법

(표 5.4)

- 오츠 알고리즘과 삼각형 알고리즘을 제외한 임계값 형식은 다중 채널 이미지에서도 적용 가능
- `Msak` 플래그를 설정하면 단순히 검은색 이미지로 변환됨
- 이진화 함수의 임계값 형식에는 `OR` 연산을 적용할 수 있으므로...
  - C#: `ThresholdTypes.Binary | ThresholdTypes.Otsu`
  - Python: `cv2.THRESH_TOZERO | cv2.THRESH_TRIANGLE`

### 1. 오츠 알고리즘

- Otsu Algorithm
- 이진화 연산 수행 시 최적의 임계값을 자동으로 게산하는 알고리즘
- 입력된 이미지의 밝기 분포를 분석해 최적의 임계값을 결정하고 이 값으로 이미지를 이진화함
- 임계값 찾기
    1. 이미지의 픽셀 값들을 히스토그램으로 표현
    2. 히스토그램을 기반으로 임게값 후보를 설정해 이미지를 두 개의 클래스로 분류
        - 히스토그램의 막대가 5개라면 4개의 임계값 후보가 생성됨
    3. 두 개의 클래스로 나뉜 밝기 분포를 통해 각 클래스의 픽셀이 어떻게 밝기 값에서 분포하는지를 나타내는 분산 계산
        - 이 분산 값들은 각 클래스의 픽셀들이 밝기 값에서 어떻게 퍼져 있는지를 측정하는 데 사용됨
    4. 분산 값을 가중 평균해 클래스 간의 분산 계산
        - 이 과정에서 임계값 후보로부터 얻어진 두 클래스의 분산을 효과적으로 결합
    5. 생성된 임계값 후보들 중 클래스 간 분산을 최대화하거나 분산의 차이를 최대화하는 최적의 임계값 선택
- 수식 5.2 오츠 알고리즘  
  $`\sigma^{2}\equiv\alpha\times\sigma_{1}^{2}+\beta\times\sigma_{2}^{2}`$
  - $`\alpha`$: 임계값을 기준으로 하위 클래스에 속하는 픽셀의 비율(가중치)
  - $`\beta`$: 임계값을 기준으로 상위 클래스에 속하는 픽셀의 비율(가중치)
  - $`\sigma_{1}^{2}`$, $`\sigma_{2}^{2}`$: $`\alpha`$ 클래스와 $`\beta`$ 클래스의 분산
  - 이 수식을 통해 0부터 255까지 임계값을 입력으로 사용해 분산을 최소화하거나 차이가 최대화되는 최적의 임계값을 찾아 적용
  - 가능한 모든 임계값 범위에 대해 연산을 수행하기 때문에 다른 이진화 연산에 비해 처리 속도가 느림

### 2. 삼각형 알고리즘

- Triangle Algorithm
- 오츠 알고리즘과 동일하게 히스토그램을 통해 최적의 임계값을 찾아 이진화를 적용하는 알고리즘
  - 오츠 알고리즘과 유사하게 이미지의 픽셀 밝기 분포를 분석해 임계값을 찾음
  - 오츠 알고리즘과는 다르게 모든 가능한 임계값을 계산하지는 않음
- 히스토그램에서 **최대 거리(Max Distance)** 를 구성할 수 있는 임계값을 찾아 이진화 적용
  - 최대 거리 구하기
      1. 최대값과 최소값을 찾아 직각 삼각형을 만듦
      2. 삼각형 빗변 길이가 최대일 때 수직인 선이 히스토그램의 최대 거리
          - 히스토그램에 그려진 선 사이의 거리가 최대인 지역값이 임계값이 됨
- 간단한 수학적 계산만 필요로 함
  - 복잡한 계산이나 최적화 과정이 불필요
- 히스토그램 분포의 특정 형태에 크게 영향을 받지 않으므로...
  - 다양한 유형의 이미지에 적용 가능
  - 다양한 환경에서 일관된 결과를 얻을 수 있음

### 3. 적응형 이진화 알고리즘

- Adaptive Binarization Algorithm
- 이미지의 각 영역마다 서로 다른 임계값 적용
- 입력 이미지를 작은 영역으로 나눈 후, 각 영역의 통계적 특성을 분석해 해당 지역의 최적 임계값 계산
  - 계산된 임계값을 사용해 영역마다 이진화 수행
  - 각 영역에서 생성된 이진화 이미지를 다시 병합해 최종 이진화 이미지를 얻음
- 조명 조건이나 배경 밝기가 다양한 이미지에 특히 유용
- 이미지 내의 밝기 분포가 달라 국소적으로 임계값을 적용해야 하는 경우 상대적으로 더 우수한 결과
- 적응형 이진화 함수
  - C#

    ```csharp
    Cv2.AdaptiveThreshold(
        Mat src,
        Mat dst,
        double maxValue,
        AdaptiveThresholdTypes adaptiveMethod,
        ThresholdTypes thresholdType,
        int blockSize,
        double c
    );
    ```

  - Python

    ```python
    dst = cv2.adaptiveThreshold(
        src,
        maxval,
        adaptiveMethod,
        thresholdType,
        blockSize,
        C
    )
    ```

  - 이진화 함수에서 사용하는 **최대값(`maxval`)** 플래그와 **임계값 형식(`thresholdType`)** 플래그를 동일하게 사용
  - 각 픽셀 주변의 `blockSize x blockSize` 영역에 대한 가중 평균 계산
  - 이후 가중 평균에서 `상수 C`를 감산한 값을 계산해 픽셀마다 적응형 임계값 $`T(x,y)`$ 설정
  - 수식 5.3 적응형 이진화 알고리즘  
    $`T(x,y) = \dfrac{1}{blocksize^{2}}\sum_{x_{i}}\sum_{y_{i}}I(x+x_{i},y+y_{i}) - c`$
    - 주변 영역의 크기인 `blockSize`와 상수 `C`에 따라 설정되는 임계값의 결과가 크게 달라짐
    - `blockSize`는 중심점이 존재할 수 있게 홀수만 가능
    - 상수 `C`는 일반적으로 양수, 경우에 따라 0이나 음수도 사용 가능
    - 적응형 이진화 방식(`adaptiveMethod`)에 따라 결과가 변함: OpenCV는 두 가지 알고리즘 지원

(표 5.5)

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-9/Program.cs#L1-L22

- `blockSize`가 너무 클 경우 연산 시간이 오래 걸림
- 상수 `C`의 값이 너무 크거나 너무 작은 경우 단순 이진화 함수보다 결과가 좋지 않을 수 있음

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-10/Program.py#L1-L11

- 일반적으로 음수 값 `C`를 잘 활용하지 않지만 목적에 따라 오히려 더 우수한 결과를 보이기도 함
  - 영역 내 평균 값이 절대값보다 더 낮으면 흰색, 높으면 검은색으로 분류
- 상수 `C`를 음수로 지정할 때에는
  - 임계값 형식(`thresholdType)`에 반전 이진화 플래그(`cv2.THRESH_BINARY_INV`)를 적용하거나
  - 이미지 반전 연산을 적용해 현재 구상하는 알고리즘에 맞게 변경

## 03 이미지 연산

- 이미지의 픽셀 값을 조작하거나 필터를 적용해 이미지를 변형하는 작업
  - 이미지에서 정보를 추출하거나 시각적으로 눈에 띄는 특징을 강조할 수 있게 됨
- 수학적 연산: 밝기 조절, 대비 조절, 색감 보정, 색상 반전
- 필터: 합성곱 연산을 통해 블러링, 샤프닝, 노이즈 제거 등 수

### 1. 픽셀 연산

- 하나 또는 둘 이상의 이미지에 대해 수학적인 연산을 수행하는 함수
- `Mat` 클래스의 행렬 연산 및 NumPy 배열 연산과 유사한 개념

#### 덧셈 함수

- C#

  ```csharp
  Cv2.Add(
      Mat src1,
      Mat src2,
      Mat dst,
      Mat mask = null,
      int dtype = -1
  );
  ```

- Python

  ```python
  dst = cv2.add(
      src1,
      src2,
      mask=None,
      dtype=None
  )
  ```

- 배열과 배열 또는 배열과 스칼라의 요소별 합 계산
  - `src1`과 `src2`의 각 요소를 더한 결과를 `dtype` 형식을 가지는 배열 `dst`에 저장
  - 스칼라와 연산하는 경우
    - 양수: 덧셈으로 연산 수행
    - 음수: 뺄셈으로 연산 수행
- 정밀도에 따라 최대값 존재
- 최대값을 넘어가면 최대값으로 **클리핑(Clipping)** 됨
- 수식 5.4 덧셈함수  
  - 두 배열의 크기와 채널 수가 같은 경우 두 배열의 요소별 합  
    $`\text{dst(I)} = \text{src1(I)} + \text{src2(I)} \quad if \; mask(I) \ne 0`$
  - 배열과 스칼라의 요소별 합  
    $`\text{dst(I)} = \text{src1(I)} + \text{src2} \quad if \; mask(I) \ne 0`$
  - 스칼라와 배열의 요소별 합  
    $`\text{dst(I)} = \text{src1} + \text{src2(I)} \quad if \; mask(I) \ne 0`$
  - $`\text{src(I)}`$는 배열, $`\text{src}`$는 스칼라
  - 마스크 배열이 존재할 경우 $`mask`$ 배열의 요소값이 0이 아닌 경우에만 연산이 유효
  - 간단한 연산의 경우 다음과 같은 수식으로 같은 결과를 얻을 수 있음  
    `dst = src1 + src2;`  
    `dst += src1;`

#### 뺄셈 함수

- C#

  ```csharp
  Cv2.Subtract(
      Mat src1,
      Mat src2,
      Mat dst,
      Mat mask = null,
      int dtype = -1
  );
  ```

- Python

  ```python
  dst = cv2.subtract(
      src1,
      src2,
      mask=None,
      dtype=None
  )
  ```

- 배열과 배열 또는 배열과 스칼라의 요소별 차이 계산
  - `src1`과 `src2`의 각 요소를 뺀 결과를 `dtype` 형식을 가지는 배열 `dst`에 저장
  - 스칼라와 연산하는 경우
    - 양수: 뺄셈으로 연산 수행
    - 음수: 덧셈으로 연산 수행
- 정밀도에 따라 최소값 존재
- 최소값보다 작아지면 최소값으로 **클리핑(Clipping)** 됨
- `src1`에서 `src2`를 빼느냐, `src2`에서 `src1`을 빼느냐에 따라 결과가 달라짐
- 수식 5.5 뺄셈함수  
  - 두 배열의 크기와 채널 수가 같은 경우 두 배열의 요소별 차  
    $`\text{dst(I)} = \text{src1(I)} - \text{src2(I)} \quad if \; mask(I) \ne 0`$
  - 배열과 스칼라의 요소별 차  
    $`\text{dst(I)} = \text{src1(I)} - \text{src2} \quad if \; mask(I) \ne 0`$
  - 스칼라와 배열의 요소별 차  
    $`\text{dst(I)} = \text{src1} - \text{src2(I)} \quad if \; mask(I) \ne 0`$
  - $`\text{src(I)}`$는 배열, $`\text{src}`$는 스칼라
  - 마스크 배열이 존재할 경우 $`mask`$ 배열의 요소값이 0이 아닌 경우에만 연산이 유효
  - 간단한 연산의 경우 다음과 같은 수식으로 같은 결과를 얻을 수 있음  
    `dst = src1 - src2;`  
    `dst -= src1;`

#### 곱셈 함수

- C#

  ```csharp
  Cv2.Multiply(
      Mat src1,
      Mat src2,
      Mat dst,
      double scale = 1,
      int dtype = -1
  );
  ```

- Python

  ```python
  dst = cv2.multiply(
      src1,
      src2,
      scale=None,
      dtype=None
  )
  ```

- 배열과 배열 또는 배열과 스칼라의 요소별 곱에 추가로 `scale`을 곱한 값을 계산
  - `src1`과 `src2`의 각 요소를 곱한 결과를 `dtype` 형식을 가지는 배열 `dst`에 저장
  - 스칼라와 연산하는 경우
    - 음수: 최소값으로 변경
- 정밀도에 따라 요소의 최대값과 최소값 존재
- 최대값을 넘어가거나 최소값보다 작아질 수 없음
  - 배열의 최대값을 넘어가기 쉽기 때문에 `scale`을 곱해 연산 결과 조절
- 정밀도가 정수형일 경우 소수점 단위는 반올림
- 수식 5.6 곱셈함수  
  - 두 배열의 크기와 채널 수가 같은 경우 두 배열의 요소별 곱  
    $`\text{dst(I)} = \text{src1(I)} \times \text{src2(I)} \times scale`$
  - 배열과 스칼라의 요소별 곱  
    $`\text{dst(I)} = \text{src1(I)} \times \text{src2} \times scale`$
  - 스칼라와 배열의 요소별 곱  
    $`\text{dst(I)} = \text{src1} \times \text{src2(I)} \times scale`$
  - $`\text{src(I)}`$는 배열, $`\text{src}`$는 스칼라
  - 간단한 연산의 경우 다음과 같은 수식으로 같은 결과를 얻을 수 있음  
    `dst = src1 * src2;`  
    `dst *= src1;`

#### 나눗셈 함수

- C#

  ```csharp
  Cv2.Divide(
      Mat src1,
      Mat src2,
      Mat dst,
      double scale = 1,
      int dtype = -1
  );
  ```

- Python

  ```python
  dst = cv2.divide(
      src1,
      src2,
      scale=None,
      dtype=None
  )
  ```

- 배열과 배열 또는 배열과 스칼라의 요소별 나눗셈에 추가로 `scale`을 곱한 값을 계산
  - `src1`과 `src2`의 각 요소를 나눈 결과를 `dtype` 형식을 가지는 배열 `dst`에 저장
  - 스칼라와 연산하는 경우
    - 음수: 최소값으로 변경
- 정밀도에 따라 요소의 최대값과 최소값 존재
- 최대값을 넘어가거나 최소값보다 작아질 수 없음
  - 배열의 최소값과 근사해지기 쉽기 때문에 `scale`을 곱해 연산 결과 조절
- 정밀도가 정수형일 경우 소수점 단위는 반올림
- 수식 5.7 나눗셈함수  
  - 두 배열의 크기와 채널 수가 같은 경우 두 배열의 요소별 나눔  
    $`\text{dst(I)} = \text{src1(I)} \div \text{src2(I)} \times scale`$
  - 배열과 스칼라의 요소별 나눔  
    $`\text{dst(I)} = \text{src1(I)} \div \text{src2} \times scale`$
  - 스칼라와 배열의 요소별 나눔  
    $`\text{dst(I)} = \text{src1} \div \text{src2(I)} \times scale`$
  - 비율과 배열의 요소별 나눔  
    $`\text{dst(I)} = scale \div \text{src2(I)}`$
  - $`\text{src(I)}`$는 배열, $`\text{src}`$는 스칼라
  - 간단한 연산의 경우 다음과 같은 수식으로 같은 결과를 얻을 수 있음  
    `dst = src1 / src2;`  
    `dst /= src1;`

#### 최대값 함수

- C#

  ```csharp
  Cv2.Max(
      Mat src1,
      Mat src2,
      Mat dst
  );
  ```

- Python

  ```python
  dst = cv2.max(
      src1,
      src2
  )
  ```

- 배열과 배열 또는 배열과 스칼라의 요소별 최대값을 계산
  - `src1`과 `src2`의 각 요소의 최대값 결과를 `dtype` 형식을 가지는 배열 `dst`에 저장
- 정밀도에 따라 요소의 최대값과 최소값 존재
- 최대값을 넘어가거나 최소값보다 작아질 수 없음
- 추가로 `src2`에 스칼라 값이 아닌 `double` 형식의 값을 활용해 배열 요소의 최대값 비교 가능
- 정밀도가 정수형일 경우 소수점 단위는 반올림
- 수식 5.8 최대값 함수  
  - 두 배열의 크기와 채널 수가 같은 경우 두 배열의 요소별 최대값  
    $`\text{dst(I)} = \max\left(\text{src1(I)}, \text{src2(I)}\right)$
  - 배열과 스칼라의 요소별 최대값  
    $`\text{dst(I)} = \max\left(\text{src1(I)}, \text{src2}\right)$
  - 스칼라와 배열의 요소별 최대값  
    $`\text{dst(I)} = \max\left(\text{src1}, \text{src2(I)}\right)$
  - 배열과 부동 소수점의 요소별 최대값  
    $`\text{dst(I)} = \max\left(\text{src1(I)}, \text{value}\right)$

#### 최소값 함수

- C#

  ```csharp
  Cv2.Min(
      Mat src1,
      Mat src2,
      Mat dst
  );
  ```

- Python

  ```python
  dst = cv2.min(
      src1,
      src2
  )
  ```

- 배열과 배열 또는 배열과 스칼라의 요소별 최소값을 계산
  - `src1`과 `src2`의 각 요소의 최소값 결과를 `dtype` 형식을 가지는 배열 `dst`에 저장
- 정밀도에 따라 요소의 최대값과 최소값 존재
- 최대값을 넘어가거나 최소값보다 작아질 수 없음
- 추가로 `src2`에 스칼라 값이 아닌 `double` 형식의 값을 활용해 배열 요소의 최소값 비교 가능
- 정밀도가 정수형일 경우 소수점 단위는 반올림
- 수식 5.9 최소값 함수  
  - 두 배열의 크기와 채널 수가 같은 경우 두 배열의 요소별 최소값  
    $`\text{dst(I)} = \min\left(\text{src1(I)}, \text{src2(I)}\right)$
  - 배열과 스칼라의 요소별 최소값  
    $`\text{dst(I)} = \min\left(\text{src1(I)}, \text{src2}\right)$
  - 스칼라와 배열의 요소별 최소값  
    $`\text{dst(I)} = \min\left(\text{src1}, \text{src2(I)}\right)$
  - 배열과 부동 소수점의 요소별 최소값  
    $`\text{dst(I)} = \min\left(\text{src1(I)}, \text{value}\right)$

#### 최소/최대 위치 반환 함수

- C#

  ```csharp
  Cv2.MinMaxLoc(
      Mat src,
      out double minVal,
      out double maxVal,
      out Point minLoc,
      out Point maxLoc,
      Mat mask = null
  );
  ```

- Python

  ```python
  minVal, maxVal, minLoc, maxLoc = cv2.minMaxLoc(
      src,
      mask
  )
  ```

- 배열의 최소값과 최대값의 위치와 값 반환
- C#: `out` 키워드를 사용해 값 반환
- `minVal`과 `minLoc`: 최소값과 최소값의 위치 반환
- `maxVal`과 `maxLoc`: 최대값과 최대값의 위치 반환
- 마스크 배열이 존재할 경우 `mask` 배열의 요소값이 0이 아닌 경우에만 연산이 유효함

#### 절대값 함수

- C#

  ```csharp
  Cv2.Abs(
      Mat src,
  );
  ```

- Python

  ```python
  dst = np.abs(
      src
  )
  ```

- 배열의 요소별 절대값 계산
- `src`의 각 요소의 절대값 결과를 입력 배열과 같은 형식의 `dst` 배열에 저장
- C#: 행렬 표현식(`MatExpr` 클래스)을 매개 변수로 활용할 수 있어 특수한 경우 적절한 연산 수행 가능
- Python: 절대값 함수가 없기 때문에 NumPy의 절대값 함수 활용
- 수식 5.10 절대값 함수  
  $`\text{dst(I)} = \text{abs}\left(|\text{src}|\right)`$

#### 절대값 차이 함수

- C#

  ```csharp
  Cv2.Absdiff(
      Mat src1,
      Mat src2,
      Mat dst
  );
  ```

- Python

  ```python
  dst = cv2.absdiff(
      src1,
      src2
  )
  ```

- 배열과 배열 또는 배열과 스칼라의 요소별 절대값 차이 계산
- `src1`과 `src2`의 각 요소의 절대값 차이 결과를 입력 배열과 같은 형식을 갖는 배열 `dst`에 저장
- 덧셈 함수나 뺄셈 함수 등에서 요소의 최대보다 크거나 최소보다 작을 때 발생하는 오버/언더플로 문제 회피 가능
- 수식 5.11 절대값 차이 함수
  - 두 배열의 크기와 채널 수가 같은 경우 두 배열의 요소별 절대값 차이  
    $`\text{dst(I)} = \text{abs}\left(|\text{src1(I)}-\text{src2(I)}|\right)`$
  - 배열과 스칼라의 요소별 절대값 차이  
    $`\text{dst(I)} = \text{abs}\left(|\text{src1(I)}-\text{src2}|\right)`$
  - 스칼라와 배열의 요소별 절대값 차이  
    $`\text{dst(I)} = \text{abs}\left(|\text{src1}-\text{src2(I)}|\right)`$

#### 비교 함수

- C#

  ```csharp
  Cv2.Compare(
      Mat src1,
      Mat src2,
      Mat dst,
      CmpType cmpop
  );
  ```

- Python

  ```python
  dst = cv2.compare(
      src1,
      src2,
      smpop
  )
  ```

- 배열과 배열 또는 배열과 스칼라의 요소별 비교 연산 수행
- `src1`과 `src2`의 각 요소의 비교 결과를 입력 배열과 같은 형식을 갖는 배열 `dst`에 저장
- `cmpop` 매개 변수를 활용해 모든 요소에 대해 일대일 비교 연산 수행 가능
- 비교 결과가 `True`: 요소의 값을 255로 변경
- 비교 결과가 `False`: 요소의 값을 0을 변경

(표 5.6)

- 수식 5.12 비교 함수
  - 두 배열의 크기와 채널 수가 같은 경우 두 배열의 요소별 비교  
    $`\text{dst(I)} = \text{src1(I) cmpop src2(I)}`$
  - 배열과 스칼라의 요소별 비교  
    $`\text{dst(I)} = \text{src1(I) cmpop src2}`$
  - 스칼라와 배열의 요소별 비교  
    $`\text{dst(I)} = \text{src1 cmpop src2(I)}`$
- 다음과 같은 수식으로 같은 결과를 얻을 수 있음  
  `dst = src <= src2;`  
  `dst = src1 > 127;`

#### 선형 방정식 시스템의 해 찾기 함수

- C#

  ```csharp
  success = Cv2.Solve(
      Mat src1,
      Mat src2,
      Mat dst,
      DecompTypes flags = DecompTypes.LU
  );
  ```

- Python

  ```python
  success, dst = cv2.solve(
      src1,
      src2,
      flags=None
  )
  ```

- 역함수를 기반으로 선형 시스템의 해를 빠르게 구해서 반환
- 부동소수점 형식(`float`, `double`)만 지원
- 수식 5.13 선형 방정식 시스템의 해 찾기 함수  
  $`\text{dst}=argmin_{x}\| A\cdot X - B \|`$
- `src1`: 정방 행렬(`nxn`)
- `src2`: 벡터(`nx1`)
- `dst`: 결과 배열로 `nx1`의 최적 벡터 $`X`$를 구함
- `flags`: 선형 시스템에서 해를 구하는 데 사용한 플래그
- 해를 찾았을 경우
  - C#: `success`가 논리 형식으로 반환
  - Python: 논리 형식의 `success`와 `ndarray` 형식의 `dst` 함께 반환

(표 5.7)

- LU 분해와 숄레스키 분해는 특이 행렬에서는 사용할 수 없음
  - 특이 행렬이 전달되면 `success`에 `False` 반환
  - `src1`이 특이 행렬이 아닌 경우 `True` 반환
- QR 인수 분해와 특이값 분해는 시스템 방정식에 대한 최소 자승해를 찾아 선형 시스템을 풀 수 있음
  - `src1`이 특이 행렬인 경우 QR 인수 분해와 특이값 분해를 사용해 해를 찾을 수 있음

#### 벡터 크기 계산

- C#

  ```csharp
  Cv2.Magnitude(
      Mat x,
      Mat y,
      Mat magnitude
  );
  ```

- Python

  ```python
  magnitude = cv2.magnitude(
      x,
      y
  )
  ```

- **X 방향 기울기 이미지(`x`)** 와 **Y 방향 기울기 이미지(`y`)** 를 조합해 **크기 이미지(`magnitude`)** 를 반환함
  - 이 크기는 해당 위치에서의 픽셀 값의 변화량을 의미함
- 수식 5.14 벡터 크기 계산 함수  
  $`\text{dst}(I) = \sqrt{{x\left(I\right)}^{2}+{y\left(I\right)}^{2}}`$

#### 벡터 방향 계산

- C#

  ```csharp
  Cv2.Phase(
      Mat x,
      Mat y,
      Mat angle,
      bool angleInDegrees = false
  );
  ```

- Python

  ```python
  angle = cv2.phase(
      x,
      y,
      angle=None,
      angleInDegrees=None
  )
  ```

- **X 방향 기울기 이미지(`x`)** 와 **Y 방향 기울기 이미지(`y`)** 를 조합해 **각도 이미지(`angle`)** 를 반환함
  - 이 각도는 해당 위치의 기울기 방향을 의미
- **각도 반환 여부(`angleInDegrees`)** 는 기울기 방향을 라디안 대신 각도(˚) 단위로 반환할지 여부
  - `True`: 각도 단위 반환
  - `False`: 라디안 단위 반환
- 수식 5.14 벡터 크기 계산 함수  
  $`\text{angle}(I) = \arctan{2\left(y\left(I\right), x\left(I\right)\right)}`$

#### 극좌표 변환

- C#

  ```csharp
  Cv2.CartToPolar(
      Mat x,
      Mat y,
      Mat magnitude,
      Mat angle,
      bool angleInDegrees = false
  );
  ```

- Python

  ```python
  magnitude, angle = cv2.catToPolar(
      x,
      y,
      magnitude=None,
      angle=None,
      angleInDegrees=None
  )
  ```

- **X 방향 기울기 이미지(`x`)** 와 **Y 방향 기울기 이미지(`y`)** 를 조합해 직교좌표계에서 극좌표계로 변환하는 데 사용
- **벡터 크기(`magnitude`)** 와 **벡터 방향(`angle`)** 을 결과값으로 반환
- **각도 반환 여부(`angleInDegrees`)** 는 기울기 방향을 라디안 대신 각도(˚) 단위로 반환할지 여부
- 벡터 크기 계산 함수와 벡터 방향 계산 함수와 동일한 작업 수행
  - 한 번의 호출로 기울기의 크기와 방향을 모두 얻을 수 있음

#### 직교좌표 변환

- C#

  ```csharp
  Cv2.PolarToCart(
      Mat magnitude,
      Mat angle,
      Mat x,
      Mat y,
      bool angleInDegrees = false
  );
  ```

- Python

  ```python
  x, y = cv2.polarToCart(
      magnitude,
      angle,
      x=None,
      y=None,
      angleInDegrees=None
  )
  ```

- **벡터 크기(`magnitude`)** 와 **벡터 방향(`angle`)** 을 조합해 극좌표계에서 직교좌표계로 변환하는 데 사용
- 수식 5.16 직교좌표 변환 함수  
  $`x\left(I\right) = \text{magnitude}\left(I\right)\cos{\left(\text{angle}\left(I\right)\right)}`$  
  $`y\left(I\right) = \text{magnitude}\left(I\right)\sin{\left(\text{angle}\left(I\right)\right)}`$

#### 정규화

- C#

  ```csharp
  Cv2.Normalize(
      Mat src,
      Mat dst,
      double alpha = 1,
      double beta = 0,
      NormTypes = normType = NormTypes.L2,
      int dtype = -1,
      Mat? mask = null
  );
  ```

- Python

  ```python
  dst = cv2.normalize(
      src,
      dist=None,
      alpha,
      beta,
      norm_type,
      dtype=None,
      mask=None
    )
  ```

- **입력 이미지(`src`)** 를 **정규화 기준(`norm_type`)** 에 따라 `alpha` 값과 `beta` 값을 활용해 정규화된 값 변환
  - 정규화 기준에 따라 `alpha`와 `beta`의 의미가 달라짐
- **출력 이미지 정밀도(`dtype`)** : **출력 이미지(`dst`)** 의 정밀도를 임의로 설정함
  - 기본값: **입력 이미지(`src`)** 의 정밀도로 설정
- **마스크 이미지(`msak`)** 가 입력될 경우 마스크 이미지의 요소값이 0이 아닌 경우에만 연산 적용

(표 5.8)

#### AND 연산 함수

- C#

  ```csharp
  Cv2.BitwiseAnd(
      Mat src1,
      Mat src2,
      Mat dst,
      Mat mask = null
  );
  ```

- Python

  ```python
  dst = cv2.bitwise_and(
      src1,
      src2,
      mask=None
  )
  ```

- 배열과 배열 또는 배열과 스칼라의 요소별 비트 단위 논리곱 연산 수행
- 배열 `src1`과 `src2`의 값을 비트 단위로 파악
  - 해당 비트에 대해 AND 연산 진행
- 반환된 결과를 입력 배열과 같은 형식을 갖는 배열 `dst`에 저장
- 수식 5.17 AND 연산 함수
  - 두 배열의 크기와 채널 수가 같은 경우 두 배열의 요소별 논리곱  
    $`\text{dst(I)}=\text{src1(I)} \land \text{src2(I)} \quad if \space mask(I) \ne 0`$
  - 배열과 스칼라의 요소별 논리곱  
    $`\text{dst(I)}=\text{src1(I)} \land \text{src2} \qquad if \space mask(I) \ne 0`$
  - 스칼라와 배열의 요소별 논리곱  
    $`\text{dst(I)}=\text{src1} \land \text{src2(I)} \qquad if \space mask(I) \ne 0`$
  - $`\text{src(I)}`$: 배열, $`\text{src}`$: 스칼라
  - 마스크 배열이 존재할 경우 $mask$ 배열의 요소값이 0이 아닌 경우에만 연산이 유효함
  - 마스크를 사용하지 않는 경우 다음과 같은 수식으로 같은 결과를 얻을 수 있음  
    `dst = src1 & src2;`

#### OR 연산 함수

- C#

  ```csharp
  Cv2.BitwiseOr(
      Mat src1,
      Mat src2,
      Mat dst,
      Mat mask = null
  );
  ```

- Python

  ```python
  dst = cv2.bitwise_or(
      src1,
      src2,
      mask=None
  )
  ```

- 배열과 배열 또는 배열과 스칼라의 요소별 비트 단위 논리합 연산 수행
- 배열 `src1`과 `src2`의 값을 비트 단위로 파악
  - 해당 비트에 대해 OR 연산 진행
- 반환된 결과를 입력 배열과 같은 형식을 갖는 배열 `dst`에 저장
- 수식 5.18 OR 연산 함수
  - 두 배열의 크기와 채널 수가 같은 경우 두 배열의 요소별 논리합  
    $`\text{dst(I)}=\text{src1(I)} \lor \text{src2(I)} \quad if \space mask(I) \ne 0`$
  - 배열과 스칼라의 요소별 논리합  
    $`\text{dst(I)}=\text{src1(I)} \lor \text{src2} \qquad if \space mask(I) \ne 0`$
  - 스칼라와 배열의 요소별 논리합  
    $`\text{dst(I)}=\text{src1} \lor \text{src2(I)} \qquad if \space mask(I) \ne 0`$
  - $`\text{src(I)}`$: 배열, $`\text{src}`$: 스칼라
  - 마스크 배열이 존재할 경우 $mask$ 배열의 요소값이 0이 아닌 경우에만 연산이 유효함
  - 마스크를 사용하지 않는 경우 다음과 같은 수식으로 같은 결과를 얻을 수 있음  
    `dst = src1 | src2;`

#### XOR 연산 함수

- C#

  ```csharp
  Cv2.BitwiseXor(
      Mat src1,
      Mat src2,
      Mat dst,
      Mat mask = null
  );
  ```

- Python

  ```python
  dst = cv2.bitwise_xor(
      src1,
      src2,
      mask=None
  )
  ```

- 배열과 배열 또는 배열과 스칼라의 요소별 비트 단위 배타적 논리합 연산 수행
- 배열 `src1`과 `src2`의 값을 비트 단위로 파악
  - 해당 비트에 대해 XOR 연산 진행
- 반환된 결과를 입력 배열과 같은 형식을 갖는 배열 `dst`에 저장
- 수식 5.19 XOR 연산 함수
  - 두 배열의 크기와 채널 수가 같은 경우 두 배열의 요소별 배타적 논리합  
    $`\text{dst(I)}=\text{src1(I)} \oplus \text{src2(I)} \quad if \space mask(I) \ne 0`$
  - 배열과 스칼라의 요소별 배타적 논리합  
    $`\text{dst(I)}=\text{src1(I)} \oplus \text{src2} \qquad if \space mask(I) \ne 0`$
  - 스칼라와 배열의 요소별 배타적 논리합  
    $`\text{dst(I)}=\text{src1} \oplus \text{src2(I)} \qquad if \space mask(I) \ne 0`$
  - $`\text{src(I)}`$: 배열, $`\text{src}`$: 스칼라
  - 마스크 배열이 존재할 경우 $mask$ 배열의 요소값이 0이 아닌 경우에만 연산이 유효함
  - 마스크를 사용하지 않는 경우 다음과 같은 수식으로 같은 결과를 얻을 수 있음  
    `dst = src1 ^ src2;`

#### NOT 연산 함수

- C#

  ```csharp
  Cv2.BitwiseNot(
      Mat src,
      Mat dst,
      Mat mask = null
  );
  ```

- Python

  ```python
  dst = cv2.bitwise_not(
      src,
      mask=None
  )
  ```

- 배열 또는 스칼라의 요소별 비트 단위 반전 연산 수행
- 배열 `src`의 값을 비트 단위로 파악
  - 각 비트에 대해 반전 연산 진행
- 반환된 결과를 입력 배열과 같은 형식을 갖는 배열 `dst`에 저장
- 수식 5.20 NOT 연산 함수
  - 배열의 요소별 반전  
    $`\text{dst(I)} = \sim\text{src} \qquad if \space mask(I) \ne 0`$
  - 스칼라의 요소별 반전  
    $`\text{dst(I)}=\text{src1} \oplus \text{src2(I)} \qquad if \space mask(I) \ne 0`$
  - $`\text{src(I)}`$: 배열, $`\text{src}`$: 스칼라
  - 마스크 배열이 존재할 경우 $mask$ 배열의 요소값이 0이 아닌 경우에만 연산이 유효함
  - 마스크를 사용하지 않는 경우 다음과 같은 수식으로 같은 결과를 얻을 수 있음  
    `dst = src1 ^ src2;`
  
https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-11/Program.cs#L1-L20

- `cmpop`
  - `CmpType.GT`
  - `src1`이 `src2`보다 요소가 클 때 유지하는 매개 변수
  - 각 채널별로 요소에 대한 간단한 비교 연산이 필요한 경우 간단하고 빠른 요소의 값 처리 가능

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-12/Program.py#L1-L8

### 2. 필터링

- Filtering
- 이미지의 픽셀 값을 조절하거나 변형하는 작업
- 이미지를 개선하거나 원하는 특징을 강조하기 위해 사용
- 이미지의 공간적 정보를 추출하거나 수정하는 목적으로도 활용
- 이미지의 각 픽셀 주변 영역의 픽셀을 고려해 새로운 값을 계산하고 이를 통해 이미지를 변형
- 핵심 원리: **합성곱(Convolution)** 연산에 기반
  - 작은 크기의 커널 또는 필터를 사용해 픽셀 간의 상호 작용을 나타내는 방법
  - 특정 부분을 강조하거나 억제함으로써 이미지의 정보를 조작함
  - 필터의 크기와 가중치는 이미지 처리의 목적에 따라 조절됨
  - 이를 통해 특징 추출이나 다양한 시각적 효과를 얻을 수 있음
- 이미지 필터링의 주된 활용 목적
    1. 시각적 품질 향상
        - 이미지에 포함된 노이즈를 감소시켜 이미지의 품질을 향상시킴
    2. 경계 검출
        - 이미지의 윤곽선을 검출하기 위해 사용됨
    3. 특징 추출
        - 이미지에서 특정 패턴이나 특징을 강조하기 위해 필터를 사용해 해당 특징을 부각시킴
    4. 시각적 효과
        - 이미지의 특정 부분을 강조해 엠보싱, 선명화, 흐림 처리, 스무딩 등을 적용함
        - 엠보싱: 이미지를 입체적으로 보이게 하는 효과를 주는 기술
        - 선명화: 세부적인 특성을 강조하고 이미지의 선명도를 높이는 작업
        - 흐림 처리: 이미지를 흐릿하게 만들어 노이즈나 잡음을 감소시키는 데 사용
        - 스무딩: 흐림 처리와 비슷하지만 미세한 손실이 발생하지 않도록 조절하는 기술
- 필터링 계산 방식은 딥러닝에서도 핵심적인 역할을 함
  - 이미지 분야의 딥러닝 모델은 주로 **합성곱 신경망(Convolutional Neural Network: CNN)** 을 사용
  - 이 모델은 이미지 필터링에 기초한 구조를 가짐

#### 합성곱 연산

- 이미지 처리 분야에서 사용되는 중요한 수학적 연산 기법 중 하나
- 이미지에서 특정 패턴을 감지하거나 추출하는 데 사용됨
- 이미지의 특정 영역에서 입력값의 분포 또는 변화량을 계산해 출력 데이터 생성
- 특정 영역 안에서 연산을 수행하므로 **지역 특징(Local Features)** 효과적으로 추출 가능
- 여러 영역의 지역 특징을 조합해 입력 데이터의 전반적인 **전역 특징(Global Features)** 까지 파악 가능
- 합성곱 연산의 특정 영역을 **커널(Kernel)**, **필터(Filter)**, **윈도(Window)**, **마스크(Mask)** 등으로 부름
- 커널
  - 고정된 크기의 작은 행렬
  - 입력 데이터와 조합되어 특정 패턴이나 특징을 감지하거나 추출하는 역할
  - 이미지에서 (x, y)의 픽셀과 해당 픽셀 주변을 포함한 작은 크기의 공간
  - 크기와 형태, 내부 수식은 작업에 따라 다름
  - 이 값을 조절하여 특징을 추출하거나 이미지를 필터링할 수 있음
  - 일반적으로 이미지 처리 분야에서는 커널의 값을 고정값으로 설정해 필터링 수행
- 커널을 사용한 이미지 필터링 적용
    1. **고정점(Anchor Point)** 설정
    2. 고정점을 기준으로 커널을 이동시키며 연산 수행
  - 이를 통해 이미지 내의 다양한 특징이나 구조를 감지하고 추출할 수 있음
  - 커널의 모양과 크기를 조절하여 다양한 이미지 처리 작업에 활용 가능
  - 연산 방법은 커널의 종류(소벨, 가우시안 등)에 따라 결정됨
- 이미지 내의 모든 픽셀에 대해 연산 수행 :arrow_right: 모든 픽셀의 값이 변화함
- 일반적으로 3x3, 5x5, 7x7 등과 같이 홀수 크기로 구성된 정방형 커널 사용
- 고정점은 주로 중앙에 위치
- 모든 픽셀에 합성곱 연산을 수행하면 이미지 테두리 부분을 처리할 때 문제가 발생함
  - (0, 0) 위치의 픽셀을 3x3 크기의 커널로 연산을 수행한다면 (-1, -1) 등의 처리 불가한 좌표가 발생  
    :arrow_right: 테두리 외삽으로 해결

#### 테두리 외삽

- 테두리의 이미지 바깥 쪽에 가상의 픽셀을 만들어 처리
  - 가상 픽셀의 값을 0으로 처리
  - 커널이 연산할 수 있는 부분부터 연산 수행
  - 이미지의 시작과 끝을 연결해 폐곡선을 형성해 이미지의 테두리 부분을 대신하게 함
- **패딩(Padding)**
  - **제로 패딩(Zero Padding)**
    - 이미지 주변을 0 또는 다른 고정값으로 채우는 방식
    - 자주 사용됨
    - 커널이 이미지의 가장자리를 처리할 때 빈 공간에 대해 0 또는 다른 값으로 처리해 문제 방지
  - **반사 패딩(Reflection Padding)**
    - 이미지의 가장자리 픽셀을 복사해 패딩하는 방식
    - 이미지의 가장자리 정보가 유지되므로 테두리 처리에 효과적
    - 연산량 증가

(표 5.9)

- 표에서 알파벳은 픽셀 값을 의미함
  - i.e. `BorderTypes.Replicate(cv2.BORDER_REPLICATE)`
    - `aaaaaa | abcdefgh | hhhhhhh` 형태로 테두리가 외삽됨
    - `abcdefgh`는 이미지의 픽셀
    - 존재하지 않는 영역: 양 옆의 `aaaaaa`과 `hhhhhhh`가 있는 부분부터
    - 양 끝단의 테두리 픽셀을 복사해서 확장한 방식: `a`와 `h`가 가상 픽셀로 설정됨

#### 커널(필터)

- 이미지 필터링
  - 각 픽셀 주변에 가중치를 적용해 주변 픽셀과 조합함으로써 이미지의 특성을 변화시키는 역할
  - 이미지 특성 변화를 위해 다양한 종류의 필터를 사용할 수 있음
- 커널 영역에 할당되는 요소값
  - 필터의 작동 정의
  - 이미지 특성을 변화시키는데 중요한 역할을 함
  - 주변 픽셀에 대한 가중치 :arrow_right: 조합해 새로운 픽셀 값 계산

#### 박스 필터 함수

- C#

  ```csharp
  Cv2.BoxFilter(
      Mat src,
      Mat dst,
      MatType ddepth,
      Size ksize,
      Point? anchor = null,
      bool normalize = true,
      BorderTypes borderType = BorderTypes.Default
  );
  ```

- Python

  ```python
  dst = cv2.boxFilter(
      src,
      ddepth,
      ksize,
      anchor=None,
      normalize,
      borderType=None
  )
  ```

- 커널 내부 값이 모두 같은 간단한 평균 필터
- **입력 이미지(`src`)** 위에 커널을 이동해가면서 커널 아래에 있는 픽셀들의 평균 값 계산
- 모든 픽셀들을 대상으로 합성곱 연산이 수행됐다면 결과는 **출력 이미지(`dst`)** 에 저장됨
- 커널 형태: **커널 크기(`ksize`)** 와 **고정점(`anchor`)** 을 활용해 설정 가능
  - 고정점: `null`이나 `None`
    - 위치가 (-1, -1)
    - 커널을 기준으로 중앙에 위치하게 됨
    - 3x3 크기의 커널일 경우 중심점은 (1, 1)이므로 (-1, -1)은 (1, 1)의 위치를 가짐
- 다른 함수와 다르게 **출력 이미지 정밀도(`ddepth`)** 설정 가능
  - -1: 입력 이미지와 동일한 정밀도
- **정규화 여부(`normalize`)**: 커널의 정규화 여부 설정
- **테두리 외삽(`borderType`)**: 패딩 방식 설정
- 일반적으로 박스 필터 커널의 모든 값은 1을 가짐
  - 정규화 여부의 값을 `True`로 지정  
    :arrow_right: **정규화된 박스 필터(Normalized Box Filter)** 가 됨  
    :arrow_right:커널의 모든 값이 커널 개수(면적) 만큼 나눠짐
- 주로 간단한 흐림 처리나 스무딩

#### 2차원 필터 함수

- C#

  ```csharp
  Cv2.Filter2D(
      Mat src,
      Mat dst,
      MatType ddepth,
      Mat kernel,
      Point? anchor = null,
      double delta = 0,
      BorderTypes borderType = BorderTypes.Default
  );
  ```

- Python

  ```python
  dst = cv2.filter2D(
      src,
      ddepth,
      kernel,
      anchor=None,
      delta=None,
      borderType=None
  )
  ```

- 박스 필터 함수와 구조적으로 유사
- 사용자가 원하는 커널을 정의해 이미지 필터링 수행 가능
  - **커널(`kernel`)** 자체를 정의해 이미지 필터링 수행 가능
- **오프셋(`delta`)**: 이미지 필터링을 조정해 출력 이미지의 밝기나 강도 변경
- 경계 검출, 특징 추출, 엠보싱, 선명화 등 다양한 사용자 지정 작업 수행 가능
  - 이런 작업을 수행하려면 필터(커널) 정의

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-13/Program.cs#L1-L29

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-14/Program.py#L1-L10

### 3. 푸리에 변환

- Fourier Transform
- 신호 처리와 이미지 처리 분야에서 주로 사용됨
- **주파수 영역(Frequency Domain)** 에서 신호를 분석하기 위한 기술
- 신호 처리 분야에서는 시간 영역을 주파수 영역으로 변경해...
  - 주파수 영역에서 신호의 특성 분석
  - 필터링, 압축 또는 특정 주파수 성분을 감지하기 위해 사용
- **시간 영역(Time Domain)** 에서의 변환
  - 1차원 푸리에 변환
  - 주어진 시간 영역의 연속적인 신호 함수를 주파수 영역으로 변환하는 수학적 변환
  - 시간 영역의 신호를 주파수 영역으로 변환하면 해당 신호가 어떤 주파수 성분으로 구성되어 있는지 파악 가능
- 주파수 영역에서의 분석을 통해...
  - 특정 주파수 대역을 걸러내거나 강조시킬 수 있음
  - 복잡한 시간 영역의 신호를 간단한 주파수 성분으로 분해 가능
- 수식 5.21 1차원 푸리에 변환  
  $`F(\omega) = \int_{-\infty}^{\infty}f\left(t\right)e^{-j2\omega t}\, dt`$
  - $`F(\omega)`$: 주파수 영역에서의 신호
  - $`\omega`$: 주파수 성분을 나타내는 **각주파수(Angular Frequency)**
  - $`f\left(t\right)`$: 주어진 시간 영역의 연속적인 신호 함수
    - $`e^{-j2\omega t}`$의 곱을 모든 시간에 대해 더한 것을 나타냄
    - 이 수식은 시간 도메인에서 주어진 함수 $`f\left(t\right)`$를 각주파수 성분 $`\omega`$를 갖는 복소 지수 함수로 분해하는 과정
- 연속적인 신호가 아닌 이산적인 신호 :arrow_right: **이산 푸리에 변환(Discrete Fourier Transform: DFT)** 주파수 신호 분석
- 수식 5.22 1차원 이산 푸리에 변환  
  $`F\left(k\right) = \overset{N-1}{\underset{n=0}{\sum}} f(n)e^{-2\pi\frac{kn}{N}}`$
  - 연속적인 신호가 아닌 이산적인 신호에 적용됨
  - 이산 데이터는 일정한 간격으로 샘플링된 데이터 포인트로 구성됨 :arrow_right: $`\sum`$
  - 데이터 정규화 및 변환 결과를 주파수 도메인에서 해석하기 위해 데이터 포인트의 총 개수($`N`$)로 나눔

#### 2차원 이산 푸리에 변환

- 이미지를 픽셀로 이루어진 신호로 간주할 수 있음
  - 픽셀 값을 주파수로 변환할 수 있음
  - 이러한 변환은 **공간 영역(Spatial Domain)** 에서 주파수 영역으로 변환하는 과정
- 공간 영역
  - 이미지가 실제 공간에서 어떻게 표현되는지를 의미
    - 픽셀로 이루어진 2차원 배열로 구성된 것 의미
  - 이미지를 공간 영역에서 분석하면 픽셀 간의 상대적 위치, 명암, 구조 등 파악 가능
- 이미지를 주파수 영역으로 변환
  - 주파수의 구성 요소 분석 가능 :arrow_right: 패턴, 가장자리와 같은 세부 정보 파악 가능
- 주파수 구성 요소
  - **고주파 성분(High Frequency)**
    - 이미지의 변화를 나타냄
    - 주로 명암 값이 급격하게 변하는 지점에서 발생
    - 가장자리, 경계, 선, 작은 텍스처, 노이즈 등과 같은 정보 파악 가능
  - **저주파 성분(Low Frequency)**
    - 명암 값이 거의 변하지 않는 지점에서 발생
    - 배경, 면적, 큰 텍스처 등 구분 가능
- 이미지에 푸리에 변환을 적용하면 픽셀 값이 얼마나 빠르게 변화하는지 계산 가능
  - 픽셀 값의 변화가 크다 :arrow_right: 객체의 경계선이나 노이즈 감지 가능
  - 이 정보를 기반으로 고주파 성분을 식별하고 제거하면...
    - 이미지의 부드러움 증가
    - 중요한 구성 요소 식별 가능
- 이미지를 주파수 영역으로 변환하기 위해 **2차원 이산 푸리에 변환(2D Discrete Fourier Transform: 2D-DFT)** 사용
  - 고주파 성분과 저주파 성분 탐지 가능
  - 이미지에서 특정 주파수 패턴이 어떻게 분포하는지 파악 가능
- 수식 5.23 2차원 이산 푸리에 변환  
  $`F(u, v) = \overset{W-1}{\underset{x=0}{\sum}} \overset{H-1}{\underset{y=0}{\sum}} f(x,y) e^{-j2\pi\left(\frac{ux}{W} + \frac{vy}{H}\right)}`$
  - $`F(u, v)`$: 2차원 이산 푸리에 변환의 결과
  - $`u`$, $`v`$: 주파수 영역에서의 공간 영역 위치
  - $`f(x,y)`$: 입력 이미지의 픽셀 좌표 $`(x, y)`$에서의 공간 영역 값
  - $`W`$, $`H`$: 각각 입력 이미지의 너비와 높이
  - $`e^{-j2\pi\left(\frac{ux}{W}+\frac{vy}{H}\right)}`$: 주파수 영역에서 특정 주파수($`\frac{u}{W}`$, $`\frac{v}{H}`$)에 해당하는 복소 지수 함수
    - $`x`$축 방향($`\frac{u}{W}`$)과 $`y`$축 방향($`\frac{v}{H}`$)의 주파수를 갖는 사인파의 기저 함수
  - 결과적으로, $`F(u, v)`$
    - 주파수 영역에서의 특정 주파수 구성 요소를 나타냄
    - **실수부(Real Part)**, **허수부(Imaginary Part)** 로 구성됨
    - 실수부: 주파수 영역에서 해당 주파수 구성 요소의 **크기(Magnitude)** 를 의미함
    - 허수부: 주파수 구성 요소의 **위상(Phase)** 정보를 의미함
    - $`F(u,v)`$의 값은 이미지에서 $`(u,v)`$ 주파수 성분의 크기와 위상을 표현함
    - $`F(0,0)`$
      - 주파수 영역에서 원점에 해당
      - 이미지의 평균 밝기(또는 진폭)를 의미함
      - **직류(DC)** 성분
- 2차원 이산 푸리에 변환 후 주파수 영역에서 주파수 성분을 조작하거나 필터링 적용  
  :arrow_right: 고주파 성분만을 추출하거나 저주파 성분만 추출 가능
- 주파수 성분 조작 후 **2차원 역 이산 푸리에 변환(2D Inversion Discrete Fourier Transform: 2D-IDFT)** 수행  
  :arrow_right: 주파수 영역에서 다시 공간 영역으로 변환
- 수식 5.24 2차원 역 이산 푸리에 변환  
  $`F(x,y) = \dfrac{1}{WH} \overset{W-1}{\underset{u=0}{\sum}} \overset{H-1}{\underset{v=0}{\sum}} F(u,v)e^{j2\pi\left(\frac{ux}{W}+\frac{vy}{H}\right)}`$
  - 2차원 공간 영역에서 주파수 도메인으로의 변환을 역으로 수행
  - 원래 함수를 복원하는 데 사용
  - 이 수식을 적용하기 전 이미지의 주파수 성분을 수정하거나 제거하고 다시 역 이산 푸리에 변환 수행  
    :arrow_right: 이미지는 주파수 영역에서 공간 영역으로 변환됨
- C# OpenCvSharp와 Python OpenCV에서의 이산 푸리에 변환 함수
  - C#

    ```csharp
    Cv2.Dft(
        Mat src,
        Mat dst,
        DftFlags flags = DftFlags.None,
        int nonzeroRows = 0
    );
    ```

  - Python

    ```python
    dst = cv2.dft(
        src,
        dst=None,
        flags=None,
        nonzeroRows=None
    )
    ```

  - **입력 배열(`src`)**
    - 이산 푸리에 변환을 계산할 입력 배열
    - 일반적으로 이산 푸리에 변환을 계산하기 전 입력 이미지를 부동 소수점 형식으로 변환해야 함
  - **출력 배열(`dst`)**
    - 이산 푸리에 변환 결과가 저장될 출력 배열
    - 주파수 공간에서의 실수 및 복소수 부분으로 나뉨
  - **플래그(`flags`)**
    - 이산 푸리에 변환 연산 시 사용할 옵션 설정
    - 주로 역 이산 푸리에 변환 계산 및 성능 향상을 지정하는 데 사용됨
  - **0이 아닌 행(`nonzeroRows`)**
    - 0을 제외한 행수 지정
    - 입력 배열의 어떤 행을 0이 아닌 값만 포함하도록 제한할 때 사용

(표 5.10)

- 역 이산 푸리에 변환
  - 역 플래그(`DftFlags.Inverse` / `cv2.DFT_INVERSE`)를 사용해 수행 가능
  - 역 이산 푸리에 변환 함수(`Cv2.Idft` / `cv2.idft`)를 통해서도 동일한 변환 수행
    - 이 함수는 이산 푸리에 변환의 역 플래그를 적용한 방식과 기능적으로 동일함
- 플래그 중 일부를 조합해 원하는 이산 푸리에 변환 계산 작동을 설정할 수 있음
  - `cv2.DFT_COMPLEX_OUTPUT | cv2.DFT_SCALE`: 복소수 결과를 정규화된 형태로 얻을 수 있음
  - `cv2.DFT_INVERSE | cv2.DFT_REAL_OUTPUT`: 역 이산 푸리에 변환을 수행하고 실수값 형태의 결과를 얻을 수 있음

#### 푸리에 스펙트럼

- Fourier Spectrum
- 푸리에 변환을 사용해 데이터의 주파수 성분을 분석하는 과정에서 얻는 결과물
  - 이 결과물은 푸리에 변환의 실수부만 사용해 시각화함
  - 주파수 영역에서 어떤 주파수 성분이 어떤 강도로 존재하는지 확인 가능
- 값이 높은 부분(밝은 부분): 해당 주파수 성분이 원본 이미지에 많이 포함됨
- 값이 낮은 부분(어두운 부분): 해당 주파수 성분이 적게 포함되어 있음
- 원본 데이터에서 어떤 주파수 성분이 주요하게 기여하는지, 또는 어떤 주파수가 노이즈로 작용하는지 등 파악 가능
- 푸리에 변환을 사용해 주파수를 시각화할 때, 푸리에 스펙트럼에서 구간이 반복되는 현상
  - 주파수 영역에서의 주파수가 **주기성(Periodicity)** 을 가지는 특징 때문에 발생
- 복소 지수 함수를 사용해 시간 또는 공간 영역의 신호를 주파수 영역으로 변환함
- 복소 지수 함수는 주파수 영역에서 주기적인 성질을 가짐
- 각 주파수 성분은 복소 평면에서 원형 궤도를 그리며 반복됨
  - 이로 인해 실수부와 허수부가 존재
  - 실수부에서는 대칭된 구간이 나타남
- 실수부
  - 네 개의 대칭된 영역으로 나눠짐
  - 푸리에 스펙트럼의 네 모서리에 직류 성분이 존재하게 됨
  - 직류 성분을 없애거나 중앙으로 이동시켜야 함 :arrow_right: **시프트(Shift)** 또는 **셔플링(Shuffling)**
- 시프트 작업으로 푸리에 스펙트럼을 중앙으로 이동시키면 주파수 성분이 더 잘 드러남
- 시프트된 푸리에 스펙트럼을 사용하면 해석 및 필터링 작업 등을 보다 효과적으로 수행할 수 있음
  - 중심이 중앙에 위치하기 때문에 원하는 주파수 성분을 강조하거나 제거하기가 더 용이해짐
  - 중심을 중앙으로 이동시키면 계산과 해석이 직관적으로 이루어져 필터링 결과를 효과적으로 조절 가능
- 시프트된 푸리에 스펙트럼의 중심부: 주파수 영역에서의 원점을 나타냄
  - 영상을 $`x`$축 또는 $`y축`$ 방향으로 따라가면서 픽셀의 밝기 변화를 주파수로 분석하는 것과 동일해짐
  - 중심에 가까운 부분: 저주파 성분
    - 전반적인 패턴이나 경향성을 나타내게 됨
  - 중심에서 멀리 떨어진 부분: 고주파 성분
    - 세부적인 패턴이나 질감을 나타내게 됨
- 푸리에 스펙트럼을 시각화할 때 주파수 데이터의 함수 범위가 매우 크므로 실행 컨텍스트에 따라 최대값과 최소값의 차이가 매우 커짐
  - 스펙트럼 시각화 시 데이터를 적절하게 스케일링하는 것이 중요
  - 대표적인 스케일링 방법: **로그 스케일링(Log Scaling)**
- 주파수 스펙트럼 데이터를 로그 스케일로 변환하면 주파수 데이터의 큰 값과 작은 값의 차이를 줄일 수 있음
  - 중요한 세부 정보를 뚜렷하게 시각화할 수 있음
  - 푸리에 스펙트럼의 로그 스케일링은 주로 **데시벨(dB)** 단위로 표시
  - 수식 5.25 푸리에 스펙트럼 로그 스케일링  
    $`dB = c\log\left(|F\left(u-\frac{W}{2}, v-\frac{H}{2}\right)| +1\right)`$
    - $`|F\left(u-\frac{W}{2}, v-\frac{H}{2}\right)|`$
      - 시프트된 푸리에 스펙트럼 이미지
      - 푸리에 스펙트럼의 크기를 나타냄
    - 여기서 로그를 취하기 전 변환된 데이터의 크기에 1을 더하는 작업 수행
      - 주파수 값이 0이 되는 것을 피하기 위함
    - 이후 스케일링된 값에 상수 $`c`$(주로 10)를 곱함

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-15/Program.cs#L1-L76

- 예제의 `Shift` 메서드
  - 입력 이미지(`Mat`)를 네 개의 사분면으로 나누고, 이 사분면을 서로 교환해 이미지를 이동
  - 푸리에 스펙트럼을 시프트하기 위해 사용됨
- `FourierSpectrum` 메서드
  - 이산 푸리에 변환 결과를 받아 푸리에 스펙트럼을 계산하고 결과 반환
  - 주파수 스펙트럼 게산에는 크기 및 로그 변환이 포함됨
  - 정규화 과정은 수식 5.25를 적용함
  - 단, 이미지 처리에서는 주로 자연 로그를 취해 정규화함
    - 자연 로그 스케일을 사용하면 밝은 영역과 어두운 영역의 대비를 높일 수 있음
    - 이미지에서 주요한 특징(경계 및 윤곽선) 강조 가능
- `Main` 메서드
  - 푸리에 변환 수행
  - 입력 이미지를 `CV_32F` 형식으로 변환
  - 이산 푸리에 변환 수행
  - `FourierSpectrum` 메서드로 스펙트럼 이미지 생성
  - `Shift` 메서드를 사용해 이산 푸리에 변환 결과 시프트
  - 주파수 영역에서 일부 주파수 성분을 제거하기 위해 이미지 중심에 검은색 사각형을 그림
  - 다시 시프트를 적용해 스펙트럼 이미지를 원상복구함
  - 본래의 주파수 이미지로 돌아온 후 역 이산 푸리에 변환 적용
    - 해당 결과를 크기 계산 및 정규화를 통해 저주파가 제거된 이미지로 출력함
- 저주파 영역을 제거하면 이미지의 구조적 정보가 상당 부분 손실됨
  - 저주파 성분: 이미지의 구조와 모양을 나타냄
- 매우 작은 크기로 이미지 중심부를 제거하더라도 이미지의 주파수 구성이 크게 변경될 수 있음
- 보통 저주파 성분을 제거하지 않지만 특정 이미지에서 배경을 제거하거나 이미지의 세부 정보를 강조하기 위해 사용 가능

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-16/Program.py#L1-L39

- 예제의 `shift` 함수는 입력 이미지의 차원을 가져와 중심으로 이동시키는 함수
  - NumPy에는 이러한 기능을 수행하는 함수인 `np.fft.fftshift`와 `np.fft.ifftshift`가 있음
- `fourier_spectrum` 함수
  - 푸리에 스펙트럼을 계산하는 함수
  - 이산 푸리에 변환 결과를 받아 중심을 이동시키고 수식 5.25를 적용함
- 이산 푸리에 변환을 수행하기 위해 이미지를 주파수 도메인으로 변경
- 특정 주파수 영역을 필터링하기 위해 마스크를 생성해 `dft` 변수에 적용
  - 마스크는 중심으로부터 100px 거리에 있는 영역을 제외한 나머지 영역은 모두 0의 값을 갖게 됨  
    :arrow_right: 곱연산을 통해 고주파 영역이 제거됨  
    :arrow_right: 저주파 영역만 남음
- 필터링된 이산 푸리에 변환 결과를 다시 중심으로 이동시키고 다시 이미지 영역으로 변환
- 고주파 영역을 제거하면 이미지에서 고주파 노이즈가 감소하고 낮은 주파수 성분이 강조됨
  - 이미지의 세부 패턴을 제거해 이미지를 흐림 처리하는 효과
  - 미세한 부분들이 제거되어 부드러운 이미지가 생성됨
- 중앙의 저주파 영역을 유지하면 이미지의 형태와 주요 특징이 대부분 보존되므로 이미지의 전반적인 구조가 유지됨

<br />

- 푸리에 스펙트럼은 공간(시간) 영역의 신호를 주파수 영역으로 변환하는 수학적 기법
- 푸리에 변환을 통해 주파수 영역에서 주요 주파수 성분을 시각화하고 분석할 수 있음
- 주파수 성분 간의 관계를 이해하기 용이함
- 계산량이 많을 수 있어 실시간 처리에 부접합
- 필터링에 사용되는 매개 변수들을 조절하기 어려움

<br />

- 단점 때문에 푸리에 스펙트럼을 사용해 특정 주파수(고주파, 저주파)를 제거하는 대신 커널을 사용해 고주파 및 저주파 필터링
- 커널을 사용하면...
  - 사용자가 원하는 대로 임의의 커널을 생성할 수 있음
  - 필요에 따라 다양한 크기, 모양 및 강도의 커널을 만들어 이미지에 적용 가능
  - 이미지에서 특정 위치에 있는 픽셀 주변의 정보를 직접 조작할 수 있음
  - 이미지의 공간적인 특징을 고려해 필터링을 수행하는 데 유용함
  - 이미지의 특정 영역에 필터를 적용할 수 있음
  - 각 픽셀에 대한 필터의 강도를 조절할 수도 있음

### 4. 고주파 필터

- High-Pass Filter
- 입력 신호에서 **고주파(High-Frequency)** 성분을 통과시키고 저주파 성분을 억제하는 필터
- 이미지는 낮은 주파수 성분과 고주파 성분이 모두 포함되어 있음
- 고주파 성분은 이미지에서 빠르게 변하는 부분이나 세부적인 패턴을 나타냄
- 이미지에 고주파 필터를 적용하면 저주파 성분을 제거하거나 줄이게 되어 고주파 성분만이 남음
  - 이미지에서 빠르게 변하는 부분을 강조하거나 추출하는 데 사용
  - 이 과정에서 이미지에 **미분(Derivative)** 을 수행하는 것과 유사한 역할을 함
- 이미지의 픽셀 값도 함수로 간주할 수 있음  
  :arrow_right: 미분을 통해 이미지의 픽셀 값이 어떻게 변화하는지 측정 가능  
  :arrow_right: 미분 연산을 통해 이미지의 픽셀 값의 변화 검출 가능  
  :arrow_right: 이러한 변화가 이미지의 고주파 정보를 의미함
- 고주파 성분
  - 픽셀의 밝기가 낮은 값에서 높은 값 또는 높은 값에서 낮은 값으로 변하는 지점을 나타냄
  - 이러한 변화는 밝기의 미분 값을 기반으로 함
  - 미분 연산을 통해 **픽셀 밝기의 변화율(Rate of Change)** 을 계산하고 변화율이 높은 부분을 고주파  성분으로 간주함
    - 주로 경계 부분에서 집중적으로 나타남 :arrow_right: 경계선이나 가장자리 감지
- 주로 1차 미분이나 2차 미분을 활용해 변화율이 높은 지점을 고주파 성분으로 판단함
- 이미지는 샘플링과 양자화로 처리된 데이터이기 때문에 단순한 밝기의 평균 변화율이 아닌 밝기의 순간 변화율을 계산해야 함
  - 이를 위해 인접한 픽셀들 간의 차이 계산
  - 합성곱 연산의 한 형태로 간주될 수 있음
- 1차 미분: **극대값(Local Maximum)** 이나 **극소값(Local Minimum)** 이 고주파 성분
- 2차 미분: **극값(Local Extrema)** 이 아니라 **제로 크로싱(Zero-Crossing)** (변곡점) 의 위치가 고주파 성분
- 픽셀 밝기에 대한 미분을 수행하기 때문에 노이즈가 심한 경우 미분이 극값이나 제로 크로싱을 정확히 감지 못할 수 있음
- 미분의 특성상 고주파 성분이 아닌 변화가 심한 지점이나 가장자리도 검출 가능
- 가장자리 종류
  - 계단형 가장자리(Step Edge)
    - 이미지의 밝기가 급격하게 변화하는 지점
    - 이러한 밝기 변화는 고주파 성분을 가짐
  - 선형 가장자리(Line Edge)
    - 이미지 밝기가 급격히 변화한 후 다시 본래의 밝기로 돌아감
    - 선이나 테두리와 같은 패턴에서 발생하므로 높은 고주파 성분을 가짐
  - 경사형 가장자리(Ramp Edge)
    - 밝기가 서서히 변화하는 경사를 가진 가장자리
    - 밝기가 부드럽게 변화하기 때문에 고주파 성분이 적음
    - 계단형 가장자리에 흐림 처리를 적용하면 경사형 가장자리가 됨
  - 지붕형 가장자리(Roof Edge)
    - 지붕과 같은 특정 형태의 가장자리
    - 선형 가장자리와 유사하나 서서히 변화하기 때문에 낮은 고주파 성분을 가짐
    - 선형 가장자리에 흐림 처리를 적용한 경우와 흡사
- 고주파 성분을 검출하는 방식으로는 크게 소벨 필터, 샤르 필터, 라플라시안 필터, 캐니 에지 등이 있음

#### 소벨 필터

- Sobel Filter
- 이미지 처리에서 미분 값을 구할 때 가장 많이 사용되는 필터
- 이미지의 가장자리 정보를 추출하거나 이미지의 미분 값을 계산하는 데 유용함
- 이미지 미분은 합성곱 연산을 통해 수행되며, 이를 위해 커널을 사용함
- 소벨 필터를 사용할 때에는 커널 크기를 홀수 값으로 설정하고 내부 원소의 합을 0으로 만드는 것이 중요함
  - 중심 픽셀과 주변 픽셀 간의 관계를 나타내고, 중심 픽셀을 강조해 미분 결과를 얻을 수 있음
  - 커널 합이 0이 되는 이유: 이미지의 밝기 변화에 불변한 연산을 수행하기 위함
  - 이러한 형태의 커널을 사용하여 이미지 미분을 명확하게 추출하고 가장자리를 정확하게 감지할 수 있음
  - 합이 0이 아니거나 짝수 크기의 커널을 사용할 경우 대칭성을 유지하기 어렵고 미분 결과가 불분명해질 수 있음

(소벨 필터의 커널 형태)

- 크게 수직 방향과 수평 방향에 대한 두 가지 커널로 구성됨
- 필터를 적용할 때 수평과 수직 커널은 이미지와 합성곱 연산을 수행해 새로운 이미지를 생성함
  - 가장자리의 강도 및 방향 정보 추출 가능
  - 가장자리가 수직 방향 또는 수평 방향으로 있을 때, 각각의 필터는 더 큰 반응을 나타냄
- 소벨 필터를 사용해 가장자리를 검출할 때...
  - 수직 방향 가장자리: 수직 방향 커널로 감지됨
  - 수평 방향 가장자리: 수평 방향 커널로 감지됨
  - 두 방향의 가장자리 강도를 조합해 최종 가장자리 강도 및 방향 정보를 얻을 수 있음
- 수식 5.26 소벨 필터  
  $`G_{x}=\dfrac{\partial^{n}src}{\partial x^{n}}`$ <br /> <br />
  $`G_{y}=\dfrac{\partial^{n}src}{\partial y^{n}}`$
  - $`G`$는 $`x`$ 또는 $`y`$ 방향으로 이미지를 n차 미분한 결과를 나타냄
  - n차 미분을 수행하는 소벨 연산은 이미지에서 n차 도함수 정보를 추출하는 데 사용될 수 있음
    - 이를 통해 이미지의 더 높은 차원의 특징이나 경계 정보 분석 가능
    - 일반적으로 n은 1 또는 2로 설정
- 소벨 필터는 거의 모든 크기의 커널에 대해 정의할 수 있음
  - 수직 및 수평 방향 뿐만 아니라 대각선 방향의 가장자리도 검출 가능
- 크기가 작은 커널은 노이즈에 민감하게 반응하는 경향이 있어 일반적으로 크기가 큰 소벨 커널이 가장자리를 더 잘 검출함
- 단, 커널의 크기가 너무 크면 세부 정보를 상실할 수 있음
- 소벨 필터 함수
  - C#

    ```csharp
    Cv2.Sobel(
        Mat src,
        Mat dst,
        MatType ddepth,
        int xorder,
        int yorder,
        int ksize = 3,
        double scale = 1,
        double delta = 0,
        BorderTypes borderType = BorderTypes.Default
    );
    ```

  - Python

    ```python
    dst = cv2.Sobel(
      src,
      ddepth,
      dx,
      dy,
      ksize=None,
      scale=None,
      delta=None,
      borderType=None
    )
    ```

  - **입력 이미지(`src`)** 를 대상으로 미분 진행
  - **출력 이미지 정밀도(`ddepth`)**
    - 반환되는 출력 이미지(`dst`)의 정밀도 설정 가능
    - 입력 이미지가 8비트의 정밀도를 갖는 경우 오버플로가 발생할 수 있어 16비트 이상을 주로 활용
  - `xorder(dx)`, `yorder(dy)`
    - 미분의 차수 설정
    - 일반적으로 0, 1, 2의 값 사용
    - 0: 해당 방향으로 미분하지 않음을 나타냄
    - 두 값의 합은 1 이상이어야 함
  - **커널 크기(`ksize`)**
    - 홀수 값만 사용 가능
    - 권장 크기: 1, 3, 5, 7
    - 커널 크기가 1인 경우 1x3 또는 3x1 커널로 계산됨
    - OpenCV에서는 7x7 커널을 초과하는 경우 나머지 영역은 0으로 채워지며 최대 31의 크기까지만 지원
  - **비율(`scale`)**, **오프셋(`delta`)**
    - 출력 이미지를 반환하기 전에 적용됨
    - 8비트 형태의 출력 이미지를 통해 미분 값을 시각적으로 확인할 때 주로 사용
    - 미분 연산 또한 합성곱 연산이므로 **테두리 외삽(`borderType`)** 적용
  - 수식 5.27 소벨 필터 출력 형태  
    $`dst=\dfrac{\partial^{xorder + yorder}src}{\partial x^{xorder} \partial y^{yorder}}`$

#### 샤르 필터

- Scharr Filter
- 이미지의 각 픽셀에 대해 가장자리 방향에서의 밝기 변화를 감지하기 위한 합성곱 연산을 사용하는 고주파 필터
- 가로와 세로 방향에 대한 두 가지 커널을 사용해 가장 자리 검출
  - 두 결과를 합산해 최종 가장자리 강도 계산
- 소벨 필터와의 주요 차이점: 커널의 가중치 설정
  - 소벨
    - 커널의 크기가 작을 수록 정확도가 떨어짐
    - 특히 3x3일 때 기울기의 각도가 수평이나 수직에서 멀어질수록 정확도가 감소하는 경향
  - 샤르 필터는 가중치를 더 정교하게 조절해 더 정확한 가장자리 검출을 수행함
- 샤르 필터의 커널
  - 소벨 필터보다 이미지의 가장자리를 뚜렷하게 검출할 수 있도록 설계됨
  - 3x3 크기의 커널에서 더 높은 정확도 제공

(샤르 필터 커널 형태)

- 샤르 필터와 소벨 필터 모두 합성곱 연산 사용
  - 계산 복잡도는 커널 크기와 이미지 크기에 따라 다를 수 있음
  - 일반적으로 소벨 필터가 더 빠르게 계산됨
  - 특히 기울기 각도가 다양한 상황에서도 높은 정확도를 유지할 수 있어 널리 사용됨
- 샤르 필터 함수
  - C#

    ```csharp
    Cv2.Scharr(
        Mat src,
        Mat dst,
        MatType ddepth,
        int xorder,
        int yorder,
        double scale = 1,
        double delta = 0,
        BorderTypes borderType = BorderTypes.Default
    );
    ```

  - Python

    ```python
    dst = cv2.Scharr(
        src,
        ddepth,
        dx,
        dy,
        scale=None,
        delta=None,
        borderType=None
    )
    ```

  - 소벨 필터 함수와 매개 변수 의미 및 활용 방식이 동일함
  - 샤르 필터 함수는 3x3 크기 커널만 지원하므로 **커널 크기(`ksize`)** 매개 변수를 사용하지 않음
  - 3x3만을 지원하는 이유: 게산 효율성, 다양한 이미지 유형에서 일반적으로 잘 작동하기 때문

#### 라플라시안 필터

- Laplacian Filter
- 영상 처리에서 사용되는 주요한 2차 미분 연산자 중 하나
  - 1차 미분
    - 일반적으로 가장자리(에지)를 감지하기 위해 사용
    - 물체의 경계를 찾기 위해 사용
- 가장자리 뿐만 아니라 해당 가장자리가 물체의 밝은 부분에서 생성됐는지, 어두운 부분에서 생성됐는지 파악 가능
- 라플라시안 연산
  - x축과 y축을 따라 미분한 값을 결합한 것
  - 이미지에서 높은 값을 갖는 지역을 밝은 객체나 가장자리 의미
  - 낮은 값을 갖는 지역은 어두운 영역이나 객체의 내부를 의미
  - 이미지에서 객체의 윤곽선이나 가장자리 감지 및 분석 가능
- 이미지의 고주파 특징인 가장자리, 경계, 노이즈 혹은 다른 중요한 변화 검출 가능
- 흐림 처리된 이미지나 노이즈가 있는 이미지에서 객체를 분리하고 중요한 특징을 도출하는 데에도 효과적

(그림 5.15)

- 커널 크기(`ksize`)가 1일 때 특수하게 적용되는 라플라시아 필터의 커널 형태 및 커널 변형
- 중심값이 음수인 라플라시안 커널: 픽셀의 밝기가 어두워지는 지점 검출 가능
- 중심값이 양수인 라플라시안 커널: 픽셀의 밝기가 밝아지는 지점 검출
- 중심 픽셀을 기준으로 상하좌우, 대각선까지 고려 가능
- 라플라시안 필터를 통과한 결과
  - 양수: 밝은 값
  - 음수: 어두운 값
  - 가장자리: 양수에서 음수, 또는 음수에서 양수로 전환되는 픽셀로 간주 가능
- 연산을 수행하려면 이미지의 기울기를 계산해야 하므로 소벨 필터 함수를 내부적으로 호출함
- 수식 5.28 라플라시안 필터  
  $`Laplace(f) = \dfrac{\partial^{2}f}{\partial x^{2}}+\dfrac{\partial^{2}f}{\partial y^{2}}`$
- 라플라시안 함수의 커널 크기(`ksize`)가 3: 소벨 연산을 통해 2차 미분 수행
  - 소벨 필터 함수의 매개 변수의 값이 `xorder(dx)=2`, `yorder(dy)=0`, `ksize=3`일 때 결과값을 더한 값과 동일
- 라플라시안 필터 함수
  - C#

    ```csharp
    Cv2.Laplacian(
        Mat src,
        Mat dst,
        MatType ddepth,
        int ksize = 1,
        double scale = 1,
        double delta = 0,
        BorderTypes borderType = BorderTypes.Default
    );
    ```

  - Python

    ```python
    dst = cv2.Laplacian(
        src,
        ddepth,
        ksize,
        scale=None,
        delta=None,
        borderType=None
    )
    ```

  - 소벨 필터 함수에 기반을 두고 있으므로 소벨 필터 함수의 매개 변수 의미와 활용 방식이 동일함
  - 차이점: 커널 크기(`ksize`)는 2차 소벨 미분 커널 크기 의미
- 수식 5.29 라플라시안 필터 출력 형태  
  $`\text{dst}=\Delta src=\dfrac{\partial^{2}src}{\partial x^{2}}+\dfrac{\partial^{2}src}{\partial y^{2}}`$

#### 케니 에지

- 가장자리 검출을 위한 알고리즘
- 비교적 간단하면서도 정확한 결과 제공
- 고주파 필터보다 성능이 월등히 좋음
- 노이즈에 민감하지 않아 다양한 강도의 가장자리 검출 가능
- **가우시안 필터(Gaussian Filter)** 를 사용해 노이즈를 제거하고 기울기의 크기와 방향을 계산해 경계 검출
- 이 과정에서 **비-최대 억제(Non-maximum suppersion)** 와 이중 임계값 처리를 통해 다양한 강도의 가장자리 검출 가능
- 알고리즘 작동 순서
    1. 노이즈 제거
        - 입력 이미지에서 노이즈를 제거하기 위해 가우시안 필터 적용
        - 미세한 노이즈를 제거해 이미지를 부드럽게 만듦
    2. 기울기 계산
        - 기울기 강도와 방향
        - 노이즈가 제거된 이미지에 소벨 커널을 수평/수직 방향으로 적용
        - 각 방향의 기울기 획득
    3. 경계 픽셀 선별
        - 경계 후보 픽셀을 선택하기 위해 비최대값 억제 수행
        - 비최대값 억제: 각 픽셀 주변에 있는 이웃 픽셀을 비교해 현재 픽셀이 그 중 가장 강한 가장자리인지 확인
        - 현재 픽셀이 가장 강한 가장자리가 아니라면 해당 픽셀을 가장자리 후보에서 제거
          - 최대값이 아닌 픽셀의 값을 0으로 변경(명백히 가장자리가 아닌 값 제거)해 가장 강한 가장자리만을 보존
    4. 히스테리시스 임계값(Hysteresis Threshold) 설정
        - 상한 임계값과 하한 임계값을 사용해...
          - 상한 임계값보다 큰 픽셀은 강한 가장자리로 분류
          - 상한 임계값과 하한 임계값 사이의 픽셀은 약한 가장자리로 분류
    5. 히스테리시스 임계값을 통한 경계 추적
        - 약한 가장자리로 분류된 픽셀이 강한 가장자리로 분류되는 픽셀과 연결되는지 확인
        - 연결되지 않은 약한 가장자리 제거
        - 약한 가장자리 픽셀 중 유효한 픽셀만 선택해 가장자리로 간주

- 구현이 비교적 간단해 다양한 이미지에 쉽게 적용 가능
- 기울기 크기만을 활용해 가장자리를 검출하므로 임계값 설정이 중요
- 실제 가장자리를 정확히 찾으려면 여러 번의 실험이 필요
- 다양한 이미지가 입력되는 환경이라면 최적의 임계값을 설정하는 알고리즘을 구현해야 할 수 있음
- 노이즈를 제거하기 위해 가우시안 필터를 사용하므로 고주파 특정으로 간주될 수 있는 가장자리도 부드럽게 처리될 수 있음
  - 계단형 가장자리가 경사형 가장자리로, 선형 가장자리가 지붕형 가장자리로 변형될 수 있음
  - 약한 강도의 가장자리가 누락될 가능성이 높아짐
- 특정 응용 분야나 이미지 유형에 따라 다른 에지 검출 알고리즘과 함께 사용될 때 최적의 결과를 얻을 수 있음
- 캐니 에지 함수
  - C#

    ```csharp
    Cv2.Canny(
        Mat src,
        Mat dst,
        double threshold1,
        double threshold2,
        int apertureSize = 3,
        bool L2gradient = false
    );
    ```

  - Python

    ```python
    dst = cv2.Canny(
        src,
        threshold1,
        threshold 2,
        apertureSize=None,
        L2gradient=None
    )
    ```

  - 8비트 단일 채널 이미지만 **입력 이미지(`src`)** 로 활용 가능
  - **출력 이미지(`dst`)** 는 단일 채널 이미지로 반환됨
  - **하위 임계값(`threshold1`)** 과 **상위 임계값(`threshold2`)** 으로 약한 가장자리 강도와 강한 가장자리 강도 설정
  - 소벨 필터에 기반을 두고 있으므로 **소벨 함수 필터 크기(`apertureSize`)** 설정: 조리개 크기
  - **L2 그레이디언트(`L2gradient`)**
    - L2 노름으로 방향성 그레이디언트를 정확히 계산할지, 정확성은 떨어지지만 속도가 더 빠른 L1 노름으로 계산할지 선택
    - `True`: L2 노름으로 계산
    - `False`: L1 노름으로 계산
    - 수식 5.30 $`L_{1}`$ 노름  
      $`L_{1} = \left| \dfrac{dI}{dx} \right| + \left| \dfrac{dI}{dy} \right|`$
    - 수식 5.31 $`L_{2}`$ 노름  
      $`L_{2} = \sqrt{\left( \dfrac{dI}{dx} \right) ^{2} + \left( \dfrac{dI}{dy} \right) ^{2}}`$

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-17/Program.cs#L1-L32

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-18/Program.py#L1-L8

### 5. 저주파 필터

- Low-Pass Filter
- 입력 신호에서 **저주파(Low-Frequency)** 성분을 통과시키고 고주파 성분을 억제하는 필터
- 주파수 영역에서 고주파 성분을 제거하거나 줄이는 역할을 하며 저주파 성분만을 통과시킴
- 고주파 성분을 제거하거나 감소시켜 세부 정보를 감소시키거나 감출 때 유용함
  - 이를 통해 이미지를 부드럽게 만들거나 노이즈를 제거하는 데 사용
  - 이미지의 부드러운 부분이나 배경 또는 잡음을 제거하고 세부 정보를 보존할 수 있음
- 중간값 필터, 가우시안 필터 등

#### 단순 흐림 처리 함수

- C#

  ```csharp
  Cv2.Bulr(
      Mat src,
      Mat dst,
      Size ksize,
      Point? anchor = null,
      BorderTypes borderType = BorderTypes.Default
  );
  ```

- Python

  ```python
  dst = cv2.bulr(
      src,
      ksize,
      anchor=None,
      borderType=None
  )
  ```

- **입력 이미지(`src`)** 에 흐림 처리를 수행하는 함수
- 이미지를 평균화하거나 흐림 처리하는 데 사용됨
- 단순 흐림 처리에 사용되는 커널의 형태는 커널의 모든 값이 커널의 개수만큼 나눠짐
- **커널 크기(`ksize`)** 를 조절해 흐림 처리의 강도 설정 가능

#### 중간값 흐림 처리 함수

- C#

  ```csharp
  Cv2.MedianBlur(
      Mat src,
      Mat dst,
      Size ksize
  );
  ```

- Python

  ```python
  dst = cv2.medianBlur(
      src,
      ksize
  )
  ```

- 고정점을 사용하지 않고 중심 픽셀 주변으로 **사각형 크기(`ksize x ksize`)** 의 이웃한 픽셀들의 중간값을 사용해 각 픽셀 값 변경
  - 고정점이 항상 커널의 중심에 있다고 가정함
- 중간값을 선택하기 위해 정사각형 형태의 커널에서 중간에 있는 값 선택
- **커널 크기(`ksize`)** 는 홀수 값만 적용 가능
- **입력 이미지(`src`)** 는 2차원 이하의 배열만 가능

#### 가우시안 흐림 처리 함수

- C#

  ```csharp
  Cv2.GaussianBlur(
      Mat src,
      Mat dst,
      Size ksize,
      double sigmaX,
      double sigmaY = 0,
      BorderTypes borderType = BorderTypes.Default
  );
  ```

- Python

  ```python
  dst = cv2.GaussianBlur(
      src,
      ksize,
      sigmaX,
      sigmaY=None,
      borderType=None
  )
  ```

- 흐림 처리 함수에서 가장 유용한 함수
- 립력 이미지의 각 지점에 가우시안 커널을 적용해 합산한 다음 출력 이미지 반환
- `sigmaX`: **x 방향의 가우스 커널 표준 편차**
- `sigmaY`: **y 방향의 가우스 커널 표준 편차**
  - 0인 경우 `sigmaX`의 값과 같아짐
- `sigmaX`와 `sigmaY`의 값을 모두 0으로 설정하면 커널 크기에 의해 자동으로 설정됨
- `sigmaX`와 `sigmaY`의 계산식  
  $`\sigma_{x} = 0.3 \times \left( \left( \dfrac{ksize.width - 1}{2} \right) - 1 \right) + 0.8`$  
  $`\sigma_{y} = 0.3 \times \left( \left( \dfrac{ksize.height - 1}{2} \right) - 1 \right) + 0.8`$
  - 커널은 0보다 커야 하며, 홀수 값만 입력 가능
- 다양한 커널에 대해 높은 성능을 내도록 최적화되어 있음
- 3x3, 5x5, 7x7 크기의 커널에 대해 우수한 성능을 보여줌

#### 양방향 필터

- C#

  ```csharp
  Cv2.BilateralFilter(
      Mat src,
      Mat dst,
      int d,
      double sigmaColor,
      double sigmaSpace,
      BorderTypes borderType = BorderTypes.Default
  );
  ```

- Python

  ```python
  dst = cv2.bilateralFilter(
      src,
      d,
      sigmaColor,
      sigmaSpace,
      dst=None,
      borderType=None
  )
  ```

- **가장자리(Edge)** 를 선명하게 보존하면서 노이즈를 우수하게 제거하는 필터링 함수
- 두 종류의 가우시안 필터로 합성곱 연산을 적용
- 다른 필터링 함수와 비교했을 때 매우 느림
- 가우시안 가중치: 픽셀의 위치와 해당 위치의 값 사용
- **지름(`d`)**
  - 필터를 적용할 각 픽셀 영역의 지름
  - 클수록...
    - 수채화처럼 변형됨
    - 알고리즘의 처리 속도가 매우 느려짐
    - 동영상을 처리하는 경우 5의 값 사용
    - 실시간으로 처리하지 않는 경우 9의 값 사용
    - -1: **시그마 공간(`sigmaSpace`)** 과 비례하도록 설정됨
- **시그마 색상(`sigmaColor`)**
  - **색상 영역(Color Domain)** 에서 사용할 가우시안 커널의 너비 설정
  - 매개 변수의 값이 클 수록 필터 강도의 범위가 넓어짐
- **시그마 공간(`sigmaSpace`)**
  - **좌표 영역(Space Domain)** 에서 사용할 가우시안 커널의 너비 설정
  - 값이 클 수록 인접한 픽셀에 영향을 미침

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-19/Program.cs#L1-L20

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-20/Program.py#L1-L8

### 6. 모폴로지 변환

#### 모폴로지

- Morphology
- 영상 처리 분야에서 형태학적인 특성을 분석하고 기하학적인 개념을 활용해 이미지에서 형태, 구조, 패턴 등을 분석하고 조작하는 데 사용되는 수학적 기법
- 이미지의 형태와 구조를 이해하고 수정하는 데 중요한 기술로 사용됨
- 모폴로지의 수학적 기반은 집합 이론을 기반으로 함
  - 이미지는 픽셀의 집합으로 간주됨
  - 영상 처리에서는 이미지를 이진 형태로 처리하는 경우가 많기 때문에 이미지를 이진 행렬로 간주 가능
  - 이러한 이진 행렬에 집합 연산을 사용해 이미지 내 형태, 패턴, 구조를 분석하고 수정 가능
  - 주로 합집합, 교집합, 차집합 등의 집합 연산 사용
    - 이미지 내 객체의 형태와 구조 감지, 변경 가능
    - 원하는 정보를 추출, 불필요한 정보 제거

#### 모폴로지 변환

- Morphological Transformations
- 모폴로지 이론을 기반으로 한 이미지 처리 기술
- 주로 이미지의 형태와 구조를 조작하거나 개선하기 위해 팽창이나 침식과 같은 연산을 적용해 이미지의 픽셀 값을 수정하는 데 주로 활용
- 팽창: 이미지에서 물체의 경계를 확장하고 픽셀 영역을 더 크게 만들어 주는 역할
- 침식: 이미지에서 물체의 경계를 축소시키고 픽셀 영역을 줄이는 역할
- **구조 요소(Structuring Element)** 를 사용해 이미지를 수정하거나 객체 특성 강조
  - 커널과 비슷한 개념이지만 이미지의 형태, 구조, 패턴을 수정하거나 추출하는 데 중점을 둠
  - 모폴로지 연산을 적용할 때 어떤 부분을 변경하거나 강조할지 결정하는 데 사용됨
- 구조 요소와 모폴로지 연산을 결합해 이미지를 수정하는 과정은 필터링과 유사하게 이뤄짐
  - 합성곱 연산과는 다르게 구조 요소와 이미지의 겹치는 부분을 찾아 변환을 수행하는 특징
  - 이러한 연산을 통해 이미지 내의 다양한 형태와 구조적 특징 추출 및 수정 가능
- 모폴로지 연산은 이미지 전처리 및 후처리 과정에서 매우 중요한 역할을 함
  - 팽창: Dilation
    - 구조 요소를 활용해 영상의 특정 영역 내의 모든 픽셀 값을 커널 내부의 최대값으로 대체하는 작업
    - 침식 연산과 반대되는 연산
    - 주변 픽셀 중 가장 밝은 값으로 현재 픽셀 변경
    - 주요 목적
        1. 노이즈 제거: 영역 확장을 통한 노이즈 제거
        2. 객체 연결: 영역 확장을 통한 객체 연결
        3. 홀 채우기: 객체 내부의 홀이나 공백을 채움
        4. 객체 확대: 객체 구조 확장
        5. 특징 추출: 특정 모양이나 패턴 추출
    - 입력 이미지의 밝은 영역 확장, 어두운 영역 감소
    - 커널의 크기나 팽창 연산을 반복 적용하는 횟수를 조절해 원하는 결과를 얻을 수 있음  
      :arrow_right: 이 과정에서 **스펙클(Speckle)** 현상(작고 밝은 점 또는 작은 영역이 무작위로 나타나는 현상) 발생 가능
  - 침식: Erosion
    - 커널(구조 요소)을 활용해 영상의 특정 영역 내 모든 픽셀 값을 커널 내부의 최소값으로 대체하는 작업
    - 팽창 연산과 반대되는 연산
    - 주변 픽셀 중 가장 어두운 값으로 현재 픽셀 변경
    - 주요 목적
        1. 노이즈 제거: 영역 축소를 통한 노이즈 제거
        2. 객체 분리: 영역 축소를 통한 객체 분리
        3. 홀 확장: 객체 내부의 홀이나 공백을 넓힘
        4. 객체 축소: 객체 구조 축소
        5. 특징 추출: 특정 모양이나 패턴 추출
    - 입력 이미지의 어두운 영역 확장, 밝은 영역 감소  
      :arrow_right: 스펙클 제거 가능
  - 팽창 연산과 침식 연산은 서로 반대 효과를 가짐
    - 어느 하나가 특정 이미지 처리 작업에 향상을 가져오지는 않음
    - 어떤 결과를 원하는가에 따라 선택되고 조합되어 사용
  - 수식 5.32 팽창 및 침식  
    $`\text{dilate}\left(x, y\right) = \underset{(i, j)\in kernel}{\max} src(x + i, y + j)`$  
    $`\text{erode}\left(x, y\right) = \underset{(i, j)\in kernel}{\min} src(x + i, y + j)`$
  - 팽창 연산과 침식 연산은 입력 이미지(`src`)에서 커널 내부의 원소값 (`i`, `j`)의 영역에 해당하는 픽셀값을 커널 내부의 최대/최소값으로 대체하는 연산
    - 각각의 최대, 최소값은 지역적(local) 최대, 최소
  - 모폴로지 연산은 구조 요소의 영향을 크게 받으며 구조 요소의 형태에 따라 결과가 달라짐
  - 구조 요소는 직사각형을 비롯해 타원, 십자 모양의 형태로도 활용 가능
- 구조 요소 생성 함수
  - C#

    ```csharp
    Mat kernel = Cv2.GetStructuringElement(
        MorphShapes shape,
        Size ksize,
        Point? anchor = null
    );
    ```

  - Python

    ```python
    kernel = cv2.getStructuringElement(
        shape,
        ksize,
        anchor=None
    )
    ```

  - **구조 요소 형태(`shape`)**, **구조 요소 크기(`ksize`)**, **고정점(`anchor`)** 을 사용해 구조 요소 생성
  - **직사각형(`Rect`)**, **십자가(`Cross`)**, **타원(`Ellipse`)** 모양의 구조 요소 생성 가능
  - 구조 요소는 커널과 유사한 역할을 함
  - 구조 요소의 크기가...
    - 너무 작으면
      - 원하는 형태의 특징을 잘 추출하지 못할 수 있음
      - 구조 요소의 형태가 미비하게 강조될 수 있음
    - 너무 크면
      - 세부적인 특징을 상실할 수 있음
      - 부수적인 정보와 같은 노이즈가 영향을 미침
  - 구조 요소 생성 함수의 고정점은 필수 매개 변수가 아님 :arrow_left: 모폴로지 함수에서 고정점 위치 지정 가능
    - 고정점을 지정하지 않으면 더 유동적인 구조 요소 생성 가능
  - 구조 요소의 형태에 따라 연산 방법이 달라져 제거되는 영역과 유지되는 영역이 변경됨

  (표 5.11)

  - 구조 요소의 형태
    - 직사각형: 내부가 모두 1
    - 십자가: 고정점을 기준으로 십자가의 형태
    - 타원: 구조 요소의 너비와 높이를 기준으로 타원 형성
  - 구조 요소의 크기에 따라 내부 요소값이 결정되므로 형태 플래그가 달라도 같은 형상을 가질 수 있음
    - 임의의 형태(삼각형, 마름모)를 구성하기 위해 C#에서는 `Mat` 클래스를 이용해 구조 생성, Python에서는 NumPy 클래스 활용

##### 모폴로지 변환 함수

- 팽창 함수
  - C#

    ```csharp
    Cv2.Dilate(
        Mat src,
        Mat dst,
        Mat element,
        Point? anchor = null,
        int iterations = 1,
        BorderTypes borderType = BorderTypes.Constant;
        Scalar? borderValue = null
    );
    ```

  - Python

    ```python
    dst = cv2.dilate(
        src,
        element,
        anchor=None,
        iterations=None,
        borderType=None,
        borderValue=None
    )
    ```

- 침식 함수
  - C#

    ```csharp
    Cv2.Erode(
        Mat src,
        Mat dst,
        Mat element,
        Point? anchor = null,
        int iterations = 1,
        BorderTypes borderType = BorderTypes.Constant,
        Scalar? borderValue = null
    );
    ```

  - Python

    ```python
    dst = cv2.erode(
        src,
        element,
        anchor=None,
        iterations=None,
        borderType=None,
        borderValue=None
    )
    ```

- 모폴로지 변환의 팽창과 침식 함수는 동일한 매개 변수의 형태를 사용함
- **입력 이미지(`src`)** 에 **구조 요소(`element`)** 를 사용해 팽창 또는 침식 적용
- **고정점(`anchor`)** 을 함수 내에서 할당 가능
- **반복 회수(`iterations`)** 를 설정해 침식 함수가 몇 회 연산할지 선택
- 합성곱 연산처럼 이미지 테두리에도 모폴로지 연산을 적용해야 하므로 **테두리 외삽(`borderType`)** 과 **테두리 색상(`borderValue`)** 설정 가능
  - 테두리 색상: 이미지 영역 밖(패딩 영역)의 기본값 의미

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-21/Program.cs#L1-L21

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-22/Program.py#L1-L10

#### 모폴로지 연산

- 모폴로지 변환의 팽창과 침식을 기본 연산으로 사용해 고급 형태학을 적용하는 변환 연산
- 입력 이미지가 이진화된 이미지라면 팽창과 침식 연산으로도 우수한 결과를 얻을 수 있으나 그레이스케일이나 다중 채널 이미지의 경우 더 복잡한 연산이 필요
- 모폴로지 연산 함수
  - C#

    ```csharp
    Mat dst = Cv2.MorphologyEx(
        Mat src,
        Mat dst,
        MorphTypes op,
        Mat? element,
        Point? anchor = null,
        int iterations = 1,
        BorderTypes borderType = BorderTypes.Constant,
        Scalar? borderValue = null
    );
    ```

  - Python

    ```python
    dst = cv2.morphologyEx(
        src,
        op,
        element,
        anchor=None,
        iterations=None,
        borderType=None,
        borderValue=None
    )
    ```

  - 모폴로지 변환의 팽창, 침식 함수와 흡사한 형태
  - 모폴로지 변환에 기반을 두고 있기 때문에 **구조 요소(`element`)**, **반복 횟수(`iterations`)**, **테두리 외삽(`borderType`)**, **테두리 색상(`borderValue`)** 를 동일하게 사용함
  - **연산자(`op`)**
    - 모폴로지 변환 함수를 조합해서 수행하는 복합 연산 방식
    - 연산자 플래그를 변경해 다양한 방식으로 사용 가능

      (표 5.12)

  - 모폴로지 연산 함수는 총 여덟 가지 모폴로지 변환을 지원함
    - 연산자 플래그에 따라 **팽창(`Dilate`)** 과 **침식(`Erode`)** 을 지원함
    - 추가로 **열림(`Open`)**, **닫힘(`Close`)**, **그레이디언트(`Gradient`)**, **탑햇(`TopHat`)**, **블랙햇(`BlackHat`)**, **히트미스(`HitMiss`)** 연산 지원

#### 열림 연산

- Open
- 팽창 연산자와 침식 연산자의 조합
- 침식 연산 후 팽창 연산 적용

1. 침식 연산으로 밝은 영역이 줄어들고 어두운 영역이 늘어남
2. 줄어든 영역을 다시 복구하기 위해 팽창 연산 적용
3. 줄어든 밝은 영역이 늘어나고 늘어난 어두운 영역이 줄어듦

- 스펙클이 사라지면서 발생한 객체의 크기 감소를 원래대로 복구 가능
  - 작은 객체나 노이즈를 제거하고 큰 객체를 보다 명확하게 유지할 수 있음
- 수식 5.33 열림 연산  
  $`\text{dst} = \text{dilate}\left(\text{erode}\left( src \right) \right)`$

#### 닫힘 연산

- Close
- 팽창 연산자와 침식 연산자의 조합
- 팽창 연산 후 침식 연산 적용

1. 팽창 연산으로 어두운 영역이 줄어들고 밝은 영역이 늘어남
2. 늘어난 영역을 다시 복구하기 위해 침식 연산 적용
3. 늘어난 밝은 영역이 줄어들고 줄어든 어두운 영역이 늘어남

- 객체 내부의 홀이 사라지면서 발생한 크기 증가를 원래대로 복구 가능
  - 객체 내부의 미세한 구멍을 제거하고 객체를 더 매끄럽게 만들 수 있음
- 수식 5.34  
  $`\text{dst} = \text{erode}\left(\text{dilate}\left(src\right)\right)`$

#### 그레이디언트 연산

- Gradient
- 팽창 연산자와 침식 연산자의 조합
- 이미지에 팽창 연산과 침식 연산을 각각 적용하고 감산 진행
  - 입력 이미지와 비교했을 때 팽창 연산은 밝은 영역이 더 큼
  - 입력 이미지와 비교했을 때 침식 연산은 밝은 영역이 더 작음
  - 각각의 결과를 감산하면 객체 가장자리가 반환됨
- 밝은 영역의 가장자리를 분리하며 그레이스케일 이미지가 가장 급격하게 변하는 곳에서 가장 높은 결과 반환
- 수식 5.35 그레이디언트 연산  
  $`\text{dst} = \text{dilate}\left(src\right)-\text{erode}\left(src\right)`$

#### 탑햇 연산

- TopHat
- 입력 이미지와 열림 연산의 조합
- 입력 이미지에 열림 연산을 적용한 이미지를 감산
  - 열림 연산이 적용된 이미지: 스펙클이 사라지고 객체의 크기가 보존된 결과
- 밝은 영역이 분리되어 사라졌던 스펙클이나 작은 부분들이 표시됨
- 입력 이미지의 객체들이 제외되고 국소적으로 밝았던 부분들이 분리됨
- 열림 연산에서 사라질 요소들을 표시함
- 수식 5.36 탑햇 연산  
  $`\text{dst} = src-\text{open}\left(src\right)`$

#### 블랙햇 연산

- BlackHat
- 입력 이미지와 닫힘 연산의 조합
- 닫힘 연산을 적용한 이미지에 입력 이미지를 감산
  - 닫힘 연산이 적용된 이미지: 객체 내부의 홀이 사라지고 객체의 크기가 보존된 결과
- 어두운 영역이 채워져 사라졌던 홀 등이 표시됨
- 입력 이미지의 객체들이 제외되고 국소적으로 어두웠던 홀들이 분리됨
- 닫힘 연산에서 사라질 요소들을 표시함
- 수식 5.37 블랙햇 연산  
  $`\text{dst} = \text{close}\left(src\right)-src`$

#### 히트미스 연산

- HitMiss
- 단일 채널 이미지에서 활용하는 모폴로지 연산자
- 주로 이진화된 이미지에 적용됨
- 이미지의 전경 또는 배경 픽셀 중에서 특정한 패턴을 찾는 데 사용됨
- **이진 형태학(Binary Morphology)** 의 한 형태로 구조 요소의 모양과 크기에 큰 영향을 받음
- 구조 요소: 앞선 구조 요소와 다른 역할
  - 0과 1의 값으로 구성됨
  - 해당 픽셀을 고려하지 않을 것인지(0, 배경), 고려할 것인지(1, 전경)를 나타냄
- 패턴 검출, 특징 추출, 객체 인식, 이미지 분할, 모서리 검출 등 다양한 응용 분야에서 활용됨
- 특정 패턴이나 객체가 이미지 내에 어디에 위치하는지를 파악하기 위해 사용됨
- 구조 요소의 정확한 설정이 연산 결과에 큰 영향을 미침
- 히트미스 제한 조건: 8-bit unsinged integers, 1-Channel

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-23/Program.cs#L1-L24

- 임의의 구조 요소를 생성해 모폴로지 연산 함수에 히트미스 플래그를 적용한 예
- 구조 요소의 크기는 7x7, 첫 번째 행과 열에 1의 요소를 할당해 시각적으로 연산 형태를 쉽게 확인 가능

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-24/Program.py#L1-L21

- NumPy 클래스로 임의의 구조 요소를 생성하고 모폴로지 연산 함수에 히트미스 플래그를 적용한 예
- 구조 요소의 크기는 5x5, X 형태로 1의 요소를 할당해 X 형태의 픽셀만 유지되도록 구성함

## 04 이미지 변환

- 데이터 개수를 적절히 조절하여 알고리즘의 연산량을 줄이거나 데이터를 더 검출하기 쉽게 조작하는 목적으로 사용
- 변환의 종류로는 크게 이미지의 크기 변환, 특정 요소의 위치 변경, 이미지의 회전 등이 있음
- 유형별 분류
    1. 강체 변환(Rigid Transformation)
        - 유클리디언 변환(Euclidean Transformation)
        - 변환의 기준점으로부터 크기와 각도가 보존되는 변환
        - 평행 이동(Translation)과 회전(Rotation)만 허용하는 변환
    2. 유사 변환(Similarity Transformation)
        - 강체 변환에 크기 변환(Scaling)까지 허용된 변환
        - 강체 변환에 등방성(Isotropic) 크기 변환이 추가되어 평행 이동, 회전, 크기 변환만 허용
    3. 선형 변환(Linear Transformation)
        - 벡터 공간 내의 선형 관계를 유지하는 변환
        - 벡터 공간에서의 선형 조합을 통한 변환
        - 벡터의 덧셈 및 스칼라 곱셈을 유지해야 함
          - 유사 변환에서 평행 이동 변환이 제외됨
        - 반사(Reflection), 기울임(Shear)이 허용됨
        - 크기 변환은 이방성(Anisotropic)을 가질 수 있음
    4. 아핀 변환(Affine Transformation)
        - 선형 변환에 이동 변환까지 포함된 변환
        - 선의 수평성을 유지함
          - 변환전에 서로 평행했다면 변환 후에도 평행함
        - 길이의 비와 평행성이 보존되는 변환
    5. 원근 변환(Perspective Transformation)
        - 원근감을 표현하기 위한 변환
        - 아핀 변환과 비슷하나 수평성은 유지되지 않음
        - 직선의 성질만 유지됨

### 1. 이미지 피라미드

- Image Pyramid
- 이미지를 원하는 단게까지 샘플링해 다양한 해상도의 이미지를 생성하는 기술
- 원본 이미지의 크기를 변경해 계층 구조의 형태로 표현함
  - 각 계층은 이전 계층의 이미지를 기반으로 생성됨
  - 아래쪽 계층에서는 이미지가 크기가 크고 높은 해상도를 갖게 됨
  - 위쪽 계층으로 올라갈수록 이미지 크기는 작아지고 해상도는 낮아짐
- 주로 객체 검출이나 추적과 같은 작업에서 다양한 크기의 물체나 동작을 인식하고 추적하는 데 사용됨
- 작은 해상도에서는 전체적인 구조 파악, 높은 해상도에서는 더 정교한 세부 정보 확인
  - 객체 검출이나 추적에서 물체의 크기나 위치가 변하는 경우에도 안정적으로 작동 가능
- 이미지 매칭에도 사용됨
- 이미지 확대(업샘플링) 및 축소(다운샘플링)를 통해 생성됨
- 업샘플링(Upsampling)
  - 이미지의 해상도를 높이는 과정
  - 이미지에서 크기가 작은 개체의 정보를 보다 상세하게 확인 가능
  - 일반적으로 보간(Interpolation) 기술을 사용해 이미지 확대
- 다운샘플링(Downsampling)
  - 이미지의 해상도를 낮추는 과정
  - 이미지를 작은 크기로 만들면 처리 속도가 향상됨
  - 특정한 패턴이나 특징을 검출하는 데 유용함
- 하위 단계(업샘플링) 생성: 원래 데이터에서 존재하지 않는 것을 생성하는 연산
- 상위 단계(다운샘플링) 생성: 일부 데이터를 제거하는 연산
- 원본 이미지를 업샘플링한 다음 다시 다운샘플링해서 본래 크기로 되돌렸다고 가정한다면...
  - 샘플링이 적용된 이미지는 원본 이미지와 데이터가 동일하지 않음
  - 다운샘플링하는 과정에서 제거된 정보를 다시 가져와 본래의 이미지 해상도로 복원해야 함
- 종류
  - 가우시안 피라미드
    - Gaussian Pyramid
    - 상위 단계 이미지를 생성하는 다운샘플링을 통해 생성됨
    - 다운샘플링 과정
        1. 이미지에 가우시안 필터 적용
        2. 짝수 행과 짝수 열을 제거하는 다운샘플링을 통해 상위 단계 이미지 생성
            - M x N 크기의 이미지를 M/2 x N/2 크기로 축소
    - 첫 번째 계층은 원본 이미지
    - 두 번째 계층은 가우시안 필터를 사용해 고주파 성분(세부 사항)을 제거해 다운샘플링으로 해상도 줄임
    - 세 번째 계층에서는 이전 계층의 이미지를 불러와 다시 가우시안 필터를 적용하고 다운샘플링 수행
    - 이런 방식으로 피라미드의 각 계층은 원본 이미지에서 세부 정보를 계속 제거하며 생성됨
  - 라플라시안 피라미드
    - Laplacian Pyramid
    - 가우시안 피라미드에서 생성됨
    - 다운샘플링된 이미지에서 본래 이미지로 복원하려면 업샘플링을 통해 원래 이미지 크기로 확대
    - 업샘플링 과정
        1. 짝수 행과 짝수 열을 추가해 0으로 채움
        2. 근사값을 채우기 위해 가우시안 필터로 합성곱 연산 수행
            - M x N 크기의 이미지를 2M x 2N 크기로 확대
    - 가우시안 피라미드의 다음 계층의 이미지를 업샘플링해 이미지를 복원하고 현재 계층의 가우시안 파리미드 이미지 간의 차이를 계산
    - 라플라시안 피라미드는 **가우시안 피라미드 계층 간의 차이(Difference Of Gaussians: DOG)** 를 근사적으로 표현하는 방법
    - 수식 5.38 라플라시안 피라미드  
      $`G_{0}=src`$  
      $`G_{i+1}=Down(G_{i})`$  
      $`L_{i}=G_{i}-Up(G_{i+1})\otimes g_{5\times 5}`$
      - $`G_{0}`$은 입력 이미지
      - $`G_{i}`$는 가우시안 피라미드 이미지
      - $`G_{i + 1}`$ 이미지를 만들기 위해 다운샘플링(`Down`)을 수행해 상위 단계의 이미지를 만듦
      - 라플라시안 피라미드는 가우시안 피라미드 이미지에서 업샘플링된 이미지(`Up`)를 감산해서 가우시안 피라미드의 차이를 계산함
      - 이때 5x5의 가우시안 커널로 합성곱 연산을 수행해 이미지를 복원함

#### 업샘플링

- 이미지 확대 함수
  - C#

    ```csharp
    Cv2.PyrUp(
        Mat src,
        Mat dst,
        Size? dstSize = null,
        BorderTypes borderType = BorderTypes.Reflect101
    );
    ```

  - Python

    ```python
    dst = cv2.pyrUp(
        src,
        dstSize=None,
        borderType=None
    )
    ```

- 행과 열을 2배로 키워 이미지를 확대하는 변환 함수
- 이미지를 업샘플링한 후 가우시안 흐림 처리 적용
- 이미지 크기를 복원하기 위해
    1. **입력 이미지(`src`)** 의 짝수 행과 짝수 열을 추가해 0으로 채움
    2. 가우시안 필터를 사용해 합성곱 연산으로 평균 밝기를 복원하는 연산
- 앞선 수식 5.38의 $`Up\left( G_{i + 1} \right) \otimes g_{5\times 5}`$ 연산과 동일
- 이때 사용되는 가우시안 필터의 값은 4로 정규화됨
- 업샘플링된 이미지에 새로 삽입된 요소는 각 차원의 방향으로 업샘플링을 수행했으므로 이미지를 평균 밝기로 복원하기 위해 4로 정규화된 커널 사용
- 출력 이미지(`dst`)의 크기는 2배 확대한 이미지가 되므로 `(src.cols x 2, src.rows x 2)`가 됨
  - **출력 이미지 크기(`dstSize`)** 를 할당하면 크기를 변경할 수 있음
  - 출력 이미지 크기를 변경하려면 다음 조건을 충족해야 함
    - $`\left| dstsize.width - src.cols \times 2 \right| \le \left(dstsize.width \mod 2 \right)`$
    - $`\left| dstsize.height - src.rows \times 2 \right| \le \left(dstsize.height \mod 2 \right)`$
  - 이 조건은 **결과 이미지(`dst`)** 의 크기가 **입력 이미지(`src`)** 크기의 약 2배인 것을 의미함
- 이미지 피라미드는 업샘플링과 다운샘플링이 함께 사용되는데, 홀수 크기의 이미지를 다운샘플링하면 1px 가량 누락 발생
  - 99 크기의 이미지를 다운샘플링 :arrow_right: 49.5 크기 :arrow_right: 49 또는 50의 크기가 됨
  - 다시 업샘플링 :arrow_right: 98 또는 100 크기를 갖는 이미지 :arrow_right: 이미지 크기가 달라짐
  - 이 문제를 방지하기 위해 출력 이미지 크기 조절

#### 다운샘플링

- 이미지 축소 함수
  - C#

    ```csharp
    Cv2.PyrDown(
        Mat src,
        Mat dst,
        Size? dstSize = null,
        BorderTypes borderType = BorderTypes.Reflect101
    );
    ```

  - Python

    ```python
    dst = cv2.pyrDown(
        src,
        dstSize=None,
        borderType=None
    )
    ```

- 입력 이미지(`src`)의 행과 열을 2배로 축소해 이미지를 축소하는 변환 함수
- 이미지에 가우시안 커널로 합성곱 연산을 수행한 후 모든 짝수 행과 짝수 열을 제거해 크기가 축소된 이미지 생성
- 이미지를 2배 작게 만들어야 하므로 홀수 크기의 이미지에는 +1을 해서 짝수 크기의 이미지로 변경
- $`G_{i}`$ 계층을 대상으로 합성곱 연산을 수행하고 모든 짝수 행과 짝수 열을 제거해 $`G_{i + 1}`$을 생성함
- 생성된 계층은 **입력 이미지(`src`)** 의 1/4에 해당하는 면적을 가짐
- **출력 이미지(`dst`)** 의 크기는 2배 축소한 이미지가 되므로 `((src.cols + 1) / 2, (src.rows + 1) / 2)`가 됨
  - **출력 이미지 크기(`dstSize`)** 를 지정해 크기 변경 가능
  - 출력 이미지 크기를 변경하려면 다음 조건을 충족해야 함
    - $`\left| dstsize.width \times 2 - src.cols \right| \le 2`$
    - $`\left| dstsize.height \times 2 - src.rows \right| \le 2`$
  - **결과 이미지(`dst`)** 의 크기가 **입력 이미지(`src`)** 크기의 약 1/2배인 것을 의미함

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-25/Program.cs#L1-L43

- **크기 정보 리스트(`sizes`)** : 다운샘플링 과정에서 이미지의 크기가 홀수 크기로 변환될 수 있으므로 가우시안 피라미드의 크기 정보 저장
- 라플라시안 이미지를 생성하기 위해 빼기 함수로 가우시안 피라미드 이미지와 업샘플링도니 이미지를 감산함
  - 고주파 성분이 강조된 라플라시안 이미지 확인 가능

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-26/Program.py#L1-L25

- Python OpenCV의 **출력 이미지 크기(`dstSize`)** 매개 변수는 (너비, 높이) 구조로 입력을 받음
  - shape 속성을 사용할 때 `(down.shape[1], down.shape[0])`의 구조로 할당해야 함

### 2. 이미지 크기 조절

- 이미지를 임의의 크기로 조절
    1. 이미지의 크기를 사용자가 요구하는 절대 크기로 변경
        - 본래의 크기에서 임의의 크기로 변환
    2. 이미지의 크기를 비율에 맞게 상대적인 크기로 변경
        - 입력 이미지의 크기와 비례하도록 너비와 높이가 계산됨
- 이미지 크기 조절 함수
  - C#

    ```csharp
    Cv2.Resize(
        Mat src,
        Mat dst,
        Size dsize,
        double fx = 0,
        double fy = 0,
        InterpolationFlags interpolation = InterpolationFlags.Linear
    );
    ```

  - Python

  ```python
  dst = cv2.resize(
      src,
      dsize,
      fx=None,
      fy=None,
      interpolation=None
  )
  ```

- **입력 이미지(`src`)** 를 **절대 크기(`dsize`)** 나 **상대 크기(`fx`, `fy`)** 로 변환
- **절대 크기(`dsize`)** : 필수 매개 변수
  - **상대 크기(`fx`, `fy`)** 로 변환하려면...
    - **절대 크기(`dsize`)** 의 값을 (0, 0)으로 설정
    - `fx`와 `fy`에 각각 x축과 y축에 적용할 비율 계수 설정
  - 상대 크기를 사용해도 절대 크기에 값을 할당하는 이유
    - `fx`와 `fy`에서 계산된 크기가 `dsize`에 할당되기 때문
    - **절대 크기(`dsize`)** 의 값이 (0, 0)이거나 **상대 크기(`fx`, `fy`)** 의 값이 (0, 0)이어야 함
  - 수식 5.39 절대 크기(`dsize`) 변환  
    $`dsize.width = round \left( fx \times src.cols \right)`$  
    $`dsize.height = round \left( fy \times src.rows \right)`$
  - 수식 5.40 상대 크기(`fx`, `fy`) 변환  
    $`fx = \dfrac{dsize.width}{src.cols}`$
    <br /> <br />
    $`fy = \dfrac{dsize.height}{src.rows}`$
- **보간법(`interpolation`)**
  - 이미지의 크기를 조절할 때 사용할 보간 방식 지정
  - 이미지를 확대하거나 축소하는 함수와는 다르게 설정해야 하는 크기와 보간법이 존재함

#### 이미지 보간법

- 이미지 크기 조절 함수는 어떤 크기로 변환될지 알 수 없으므로 보간법을 활용함

(표 5.13)

- 이미지의 비율을 변경하면 존재하지 않는 영역에 새로운 픽셀 값을 매핑하거나 현재 픽셀들을 압축해서 새로운 값을 할당해야 함
  - 이미지상에 존재하는 픽셀 데이터 $`\left( x_{i}, y_{i} \right)`$들에 대해 근사 함수 $`f(x, y)`$로 새로운 픽셀 값을 구하는 것
- 이미지의 크기를...
  - 늘림: 입력 이미지의 픽셀 값을 결과 이미지의 새로운 좌표에 모두 매핑하고 비어 있는 픽셀은 보간법을 활용해 새로운 값을 배치
  - 줄임: 입력 이미지의 픽셀이 결과 이미지 새로운 좌표에 매핑될 때 가장 근사한 값을 갖는 좌표로 픽셀값이 매핑됨
- 이미지를 늘이거나 줄일 때 새롭게 할당해야 하는 픽셀은 대부분 **분수 픽셀(Fractional Pixel)** 위치에 있음
  - 새로운 픽셀 값을 보간해서 찾아야 함
  - 보간법에 따라 어떤 방식으로 픽셀을 매핑할지 결정됨
- 보간법 종류
  - 최근접 이웃 보간법
    - 분수 픽셀 위치에서 가장 가까운 원본 픽셀을 결과 이미지의 픽셀값으로 사용함
    - 이미지가 픽셀화된 형태를 유지하며, 부드럽지 않을 수 있음
  - 이중 선형 보간법
    - 분수 픽셀 위치에서 2 x 2 크기의 주변 원본 픽셀과 가까운 거리에 따라 선형적으로 가중치를 할당해 새로운 픽셀 값 계산
    - 주변 4개 셀의 가중 평균을 사용하므로 이미지가 부드러운 변화를 보임
    - 가장 많이 사용되는 보간법
  - 비트 단위 이중 선형 보간법
    - 주변 픽셀 값을 사용해 보간 수행
    - 비트 단위 값을 보존하면서 보간을 수행하므로 정밀도를 보존하면서 이미지를 보간함
    - 픽셀 손실을 최소화할 수 있음
  - 영역 보간법
    - 픽셀 간의 관계를 고려해서 리샘플링
    - 결과 이미지의 픽셀 위치를 입력 이미지의 픽셀 위치에 배치하고 겹치는 영역의 평균을 구해 결과 이미지의 픽셀 값으로 사용
  - 큐빅 보간법
    - 분수 픽셀 위치에서 4 x 4 크기의 주변 원본 픽셀을 **3차 큐빅 스플라인(Cubic Spline)** 으로 계산해 사용
      - 3차 큐빅 스플라인: 데이터 포인트를 부드럽게 연결하여 연속적이고 부드러운 곡선을 생성하는 보간 기술
    - 주변 픽셀 값에 대한 가중 평균을 계산하므로 조금 더 부드러운 보간 방식
  - 란초스 보간법
    - 바이큐빅 보간법와 유사한 방식
    - 분수 픽셀 위치에서 8 x 8 크기의 주변 원본 픽셀을 계산해 사용
    - 고주파 잡음을 줄이기 위한 더 정교한 보간 기술 중 하나
    - 이미지의 품질을 높이기 위해 사용됨
    - 이미지의 선명도를 높이는 효과가 있음
- 기본적으로 이중 선형 보간법을 가장 많이 활용함
  - 이미지를 확대하는 경우 이중 선형 보간법이나 바이큐빅 보간법 사용
  - 이미지를 축소하는 경우 영역 보간법을 주로 활용
    - 영역 보간법은 이미지를 확대하는 경우 최근접 이웃 보간법과 비슷한 결과를 보이기도 함
- 보간법에 따라 결과 이미지가 크게 달라지므로 프로그램의 목적에 따라 보간법 선택

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-27/Program.cs#L1-L21

- 이미지 크기를 조절하거나 관심 영역을 설정할 경우 이미지 크기는 다시 계산되어 할당하므로 기본 생성자를 사용하거나 임의의 값을 할당해 사용해도 됨
- **상대 크기(`fx`, `fy`)** 의 값을 활용하려면 필수 매개 변수인 **절대 크기(`dsize`)** 에 값이 할당되어 있어야 함
  - 사이즈 구조체의 **너비(`width`)** 나 **높이(`height`)** 값이 둘 중 하나라도 0의 크기를 가져야 함
  - 둘 중 하나라도 0의 크기를 갖는다면 상대 크기를 사용하는 것으로 간주함

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-28/Program.py#L1-L10

### 3. 이미지 대칭 및 회전

- 선형 변환을 통해 수행되는 수학적 연산
- 벡터 공간에서의 변환을 나타내며, 이미지 처리에서는 이미지의 모든 픽셀에 대한 수학적 연산으로 구성됨
- 특별한 선형 변환 행렬을 사용해 수행됨
- 주로 데이터 정규화 및 일반화를 위한 전처리 단계로 활용
- 이미지를 대칭하거나 회전시켜 방향을 조정함으로써 알고리즘의 일관성을 유지할 수 있음
- 특정 방향으로 이미지를 회전시켜 결과를 더 쉽게 분석하고 해석할 수 있음
- 머신러닝 관점에서: 학습 데이터의 일관성을 유지하거나 데이터의 다양성을 높이는 데 활용, 머신러닝 모델의 일반화 능력 향상

#### 대칭

- Symmetry
- 기하학적인 측면에서 **반사(Reflection)** 의 의미를 가짐
- 주로 2차원 유클리트 공간에서의 기하학적 변환 중 하나로 사용됨
- 2차원 유클리드 공간인 $`R^{2}`$상에서의 선형 변환을 의미함
- 대칭 변환
  - 어떤 행렬(또는 이미지)에 대해 2 x 2 행렬을 왼쪽에서 곱해 적용되는 변환
  - 행렬 곱셈을 사용해 수행되며, 주로 두 축을 기준으로 대칭되는 형태로 변환됨
  - 2차원 평면 위의 점들을 다른 점으로 매핑하는 변환
  - Y축 대칭 변환
    - 주어진 점 $`(x, y)`$를 Y축을 중심으로 대칭시키는 것
    - 새로운 점 $`(x', y')`$는 $`x'=-x`$, $`y'=y`$로 계산될 수 있음
    - 하지만 이미지는 음수 좌표가 존재하지 않음
    - 결국 새로운 점의 위치는 $`x' = width - x - 1`$, $`y' = y`$로 표현됨
- 대칭 변환은 단순히 원본 행렬에서의 축을 따라 재매핑을 수행하면 대칭된 행렬을 얻을 수 있음
- 대칭 변환 시 사용되는 축 대칭 행렬은 2 x 2 **반사 행렬(Reflection Matrix)** 을 왼쪽에 곱하여 얻을 수 있음
- 변환된 결과 이미지는 **그래픽스 좌표계(Graphics Coordinates)** 에 맞게 재설정됨
  - 다른 변환과 결합해 원하는 출력 이미지를 얻을 수 있음
- 대칭 함수
  - C#

    ```csharp
    Cv2.Flip(
        Mat src,
        Mat dst,
        FlipMode flipCode
    );
    ```

  - Python

    ```python
    dst = cv2.flip(
        src,
        flipCode
    )
    ```

  - **입력 이미지(`src`)** 의 행과 열을 바꾸기 위해 축을 기준으로 이미지를 반사하는 함수
  - **대칭 축(`flipCode`)** 을 설정해 이미지의 대칭 방향을 선택할 수 있음
  - 일반적으로 카메라가 캡쳐한 이미지가 화면에 정확하게 표시되도록 조정하거나 이미지의 원점을 서로 다른 위치로 이동할 때 활용

    (표 5.14)

  - **대칭 축(`flipCode`)** 의 값이...
    - 음수일 경우 XY축 대칭 수행
    - 0이라면 X축을 기준으로 대칭을 진행함
    - 양수라면 Y축을 기준으로 대칭
  - 대칭 함수의 플래그는양수, 0, 음수 값으로 표기하므로 다른 함수와 다르게 `OR(|)` 연산 불가

#### 회전

- Rotation
- 물체를 중심점을 중심으로 회전시키는 작업
- **회전 행렬(Rotation Matrix)** 을 사용해 회전 수행
  - 임의의 점을 중심으로 물체를 회전시킴
  - 회전 변환 행렬의 일부는 반사 행렬과 동일한 값을 가질 수 있음
- 2차원 유클리드 공간에서의 회전 유형
  - 좌표값 회전  
    $`\begin{bmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta \end{bmatrix}`$
    - 특정 각도만큼 좌표값(점)을 중심으로 회전시키는 데 사용
    - 점의 위치를 회전하고 좌표값을 변환하는 데 유용
  - 좌표축 회전  
    $`\begin{bmatrix} \cos\theta & \sin\theta \\ -\sin\theta & \cos\theta \end{bmatrix}`$
    - 좌표축 자체를 회전시킴
    - 좌표값은 변경되지 않고 좌표축이 회전됨
    - 전체 좌표 시스템을 회전시켜 좌표값을 새로운 방향으로 매핑하는 데 사용됨
- 회전 행렬은 원점을 중심ㄴ으로 한 회전만 가능함
  - 임의의 중심점을 기반으로 회전을 수행하려면 아핀 변환에 기반을 둔 회전 행렬을 활용해야 함

##### 2 X 3 회전 행렬

$`\begin{bmatrix} \alpha & \beta & \left(1 - \alpha\right)\times Center_{x}-\beta \times Center_{y} \\ -\beta & \alpha & \beta \times Center_{x} - \left(1 - \alpha\right) \times Center_{y} \end{bmatrix}`$  
$`\alpha = scale \times \cos\theta`$  
$`\beta = scale \times \sin\theta`$

- $`Center`$: 중심점의 좌표
- $`scale`$: 비율
- $`\theta`$: 회전 각도
- 이 회전 행렬은 부동 소수점의 형태로 반환함
- 2 x 3 회전 행렬 생성 함수
  - C#

    ```csharp
    Mat matrix = Cv2.GetRotationMatrix2D(
        Point2f center,
        double angle,
        double scale
    );
    ```

  - Python

    ```python
    matrix = cv2.getRotationMatrix2D(
        center,
        angle,
        scale
    )
    ```

  - **중심점(`center`)**
    - 회전의 기준이 될 중심
    - 원점은 좌측 상단(0, 0)
  - **각도(`angle`)**
    - 이미지가 회전될 회전각
    - 도(˚) 단위와 반시계 방향을 가짐
  - **비율(`scale`)**
    - 회전 후의 이미지의 확대 또는 축소 비율
    - 비율의 조정이 없는 경우 1.0 값 사용
  - 2 x 3 회전 행렬 생성 함수는 부동 소수점 형태의 2 x 3 **매핑 변환 행렬(`matrix`)** 반환

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-29/Program.cs#L1-L21

- **원본 이미지(`src`)** 를 Y축으로 대칭한 다음 이미지의 중심점을 기준으로 이미지 비율의 변화 없이 90˚ 회전한 예
- 임의의 중심점을 기반으로 회전하는 것은 아핀 변환에 기반을 둔 행렬이므로 아핀 변환 함수를 적용해야 함
- 이미지의 회전을 위치 아핀 변환을 적용하면 회전 특성상 이미지의 크기를 재조정해야 함
- **출력 이미지(`dst`)** 의 이미지 크기를 알맞게 설정하지 않는다면 단순히 회전을 수행함
  - 일부 이미지가 누락되거나 불필요한 정보가 반환됨
- 회전 후의 크기와 표시되는 이미지를 올바르게 설정하려면 **매핑 변환 행렬(`matrix`)** 의 값을 수정하고 **출력 이미지(`dst`)** 의 크기를 변환 후의 크기와 맞게 고려해 값 할당

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-30/Program.py#L1-L25

- 회전 후에 발생하는 이미지의 누락과 **출력 이미지(`dst`)** 의 이미지 크기 오류를 해결한 예
- **매핑 변환 행렬(`matrix`)** 의 세 번째 열의 값을 일부 변경해야 새로운 공간에 맞게 할당 가능
  - **출력 이미지(`dst`)** 의 이미지 크기를 회전 후의 이미지 크기와 맞게 변형해야 하기 때문에 조정
- 매핑 변환 행렬의 값은 회전 행렬에서 계산한 값과 차이 발생
  - 새롭게 **바운딩(`bounding`)** 하기 위해 다음 수식을 활용해 변경된 **출력 이미지(`dst`)** 의 이미지 크기 계산
    - 수식 5.41 회전 후의 이미지 크기  
      $`boundingWidth = height\times scale \times \sin\theta + width \times scale \times \cos\theta`$  
      $`boundingHeight = height\times scale \times \cos\theta + width \times scale \times \sin\theta`$
  - 이미지를 회전했을 때 마름모 형태를 직사각형으로 감싸는 사각형을 재생성해야 함
  - 비율이 조절된 경우 너비와 높이에 비율의 값이 반영되지 않았으므로 **비율(`scale`)** 을 포함해서 계산
  - 이미지 크기는 음수가 발생하지 않으므로 `sin`과 `cos`에 **절대값(`abs`)** 을 취해 계산
  - 바운딩 공간은 이미지 좌측 상단(0, 0)을 기준으로 새롭게 생성되었으므로 이미지를 다시 중심으로 옮길 필요가 있음
    - 중심으로 다시 옮기긱 위해 **매핑 변환 행렬(`matrix`)** 에 변환의 차이를 추가로 포함
    - 수식 5.42 회전 후의 이미지 중심점  
      $`\text{matrix[0,2]} += boundingCenter_{x} - Center_{x}`$  
      $`\text{matrix[1,2]} += boundingCenter_{y} - Center_{y}`$
    - **매핑 변환 행렬(`matrix`)** 에 크기가 변형된 바운딩 공간의 중심점에서 기존 중심점 좌표를 감산한 값을 가산함
    - 회전 행렬과 바운딩 공간은 이미 **비율(`scale`)** 에 대한 값이 할당되어 있으므로 연산에 활용하지 않음

### 4. 기하학적 변환

- Geometric Transformation
- 기존의 도형, 공간 또는 그래픽 요소를 새로운 형태로 변환하는 수학적인 연산이나 변환 과정을 의미함
- 원본 객체를 그대로 유지하면서 위치, 방향, 크기, 형태 등을 변경 :arrow_right: 이미지를 구성하는 픽셀들 좌표값의 위치를 재배치하는 과정
- 아핀 변환: 2 x 3 행렬을 사용하며 행렬 곱셈에 벡터 합을 활용해 표현할 수 있는 변환
- 원근 변환: 3 x 3 행렬을 사용하며 **호모그래피(Homography)** 로 모델링할 수 있는 변환
  - 호모그래피: 한 평면의 점을 다른 평면의 점으로 매핑해서 뒤틀림, 오목함 등을 구현할 수 있는 변환

#### 아핀 변환

- Affine Transformation
- 기본적인 형태는 3 x 3 행렬로 나타냄
  - 이 행렬을 사용해 2차원 공간에서의 점, 선, 또는 객체들을 변환함
- 원근 변환과 비교해 선의 수평성을 유지하며, 변환 전의 서로 평행한 선은 변환 후에도 평행함 유지
- 아핀 변환 행렬의 기본 형태  
  $`\begin{bmatrix} x_{2} \\ y_{2} \\ 1 \end{bmatrix} = \begin{bmatrix} a_{00} & a_{01} & b_{0} \\ a_{10} & a_{11} & b_{1} \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x_{1} \\ y_{1} \\ 1 \end{bmatrix}`$  
  $`\begin{bmatrix} x_{2} \\ y_{2} \\ 1 \end{bmatrix} = \begin{bmatrix} a_{00}x_{1} + a_{01}y_{1} + b_{0} \\ a_{10}x_{1} + a_{11}y_{1} + b_{1} \\ 0 + 0 + 1 \end{bmatrix}`$
  - $`(a_{00}, a_{01})`$: X축의 크기 및 회전 변환
  - $`(a_{10}, a_{11})`$: Y축의 크기 및 회전 변환
  - $`(b_{0}, b_{1})`$: X, Y축으로의 이동 변환
  - $`(0, 0, 1)`$: 항상 같은 값
  - $`x_{1}`$, $`y_{1}`$: 변환 전 원본 이미지의 픽셀 좌표
  - $`x_{2}`$, $`y_{2}`$: 변환 후 결과 이미지의 픽셀 좌표
  - 변환 후의 픽셀 좌표를 계산하려면 미지수 $`a_{00}`$, $`a_{01}`$, $`a_{10}`$, $`a_{11}`$, $`b_{0}`$, $`b_{1}`$의 값을 알아야 함
    - 세 개의 좌표를 활용해 미지수를 계산함
- 아핀 변환은 임의의 세 개의 점을 매핑해 기하학적 변환을 수행함
- 임의 위치인 A, B, C의 픽셀 좌표를 A', B', C'로 이동한 좌표를 **아핀 맵 행렬(Affine Transformation Matrix)** 로 계산해서 아핀 변환 수행
  - 여섯 개의 미지수를 구하기 위해 세 개의 픽셀 좌표를 재매핑해서 아핀 맵 행렬로 계산하는 것
- 아핀 맵 행렬 생성 함수
  - **변환 전 세 개의 픽셀 좌표(`src`)** 와 **변환 후 세 개의 픽셀 좌표(`dst`)** 를 이용해 **아핀 맵 행렬(`M`)** 을 생성함
  - C#

    ```csharp
    Mat M = Cv2.GetAffineTransform(
        IEnumerable<Point2f> src,
        IEnumerable<Point2f> dst
    );
    ```

    - 제네릭 컬렉션을 활용해 객체 목록(`List`)에 담아 계산(`Point2f[]` 구조체 형식도 가능)

  - Python

    ```python
    M = cv2.getAffineTransform(
        src,
        dst
    )
    ```

    - 모든 배열과 행렬이 NumPy 배열로 통일되어 있으므로 `ndarray` 클래스 사용
    - 정밀도(`dtype`)는 `float32`를 지정함
  - 아핀 맵 행렬 M을 출력하면 2 x 3 행렬로 표현됨
    - 3 x 3 행렬의 맨 아래 행이 x축과 y축의 원근 변황을 나타내고 아핀 변환에는 원근 변환 1이 포함되지 않기 때문
    - OpenCV에서 사용되는 변환은 2차원 평면에서 이루어지므로 이동, 회전, 크기, 기울임 등의 변환만 수행해 2 x 3 행렬로 표현
      - 실제 아핀 변환 행렬은 3 x 3이지만 OpenCV에서는 불필요한 연산을 줄이기 위해 2 x 3 행렬로 표현
- 아핀 변환 함수
  - C#

    ```csharp
    Cv2.WarpAffine(
        Mat src,
        Mat dst,
        Mat M,
        Size dsize,
        InterpolationFlags flags = InterpolationFlags.Linear,
        BorderTypes borderMode = BorderTypes.Constant,
        Scalar? borderValue = null
    );
    ```

  - Python

    ```python
    dst = cv2.warpAffine(
        src,
        M,
        dsize,
        dst=None,
        flags=None,
        borderMode=None,
        borderValue=None
    )
    ```

  - **입력 이미지(`src`)** 에 **아핀 맵 행렬(`M`)** 을 적용하고 **출력 이미지 크기(`dsize`)** 로 변형해서 **출력 이미지(`dst`)** 를 반환함
  - 이미지를 변형하기 때문에 **보간법(`flags`)** 과 **테두리 외삽법(`borderMode`)** 을 설정함
  - **테두리 색상(`borderValue`)**: 변환 후에 발생하는 공백의 공간에 할당할 색상
    - **출력 이미지 크기(`dsize`)** 를 정교하게 설정해도 공백의 공간이 발생하는데, 이때 이 공백의 공간에 할당할 임의의 픽셀값

#### 원근 변환

- Perspective Transformation
- 3 x 3 행렬
- 아핀 변환 행렬의 기본형과 유사하나 아핀 변환에서 유지되는 수평성은 유지되지 않음
- 뒤틀림이나 원근 왜곡을 표현해야 하므로 더 많은 미지수를 요구함
- 원근 변환 행렬  
  $`\begin{bmatrix} x_{2} \\ y_{2} \\ 1 \end{bmatrix} = \begin{bmatrix} a_{00} & a_{01} & b_{0} \\ a_{10} & a_{11} & b_{1} \\ a_{20} & a_{21} & 1 \end{bmatrix} \begin{bmatrix} x_{1} \\ y_{1} \\ 1 \end{bmatrix}`$  
  $`\begin{bmatrix} x_{2} \\ y_{2} \\ 1 \end{bmatrix} = \begin{bmatrix} a_{00}x_{1} + a_{01}y_{1} + b_{0} \\ a_{10}x_{1} + a_{11}y_{1} + b_{1} \\ a_{20}x_{1} + a_{21}y_{1} + 1 \end{bmatrix}`$
  - 아핀 변환 행렬과 비슷한 형태
  - 세 번째 행의 값이 $`0, 0, 1`$에서 미지수 $`a_{20}, a_{21}, 1`$로 변경되어 여덟 개의 미지수가 됨
    - 추가된 두 개의 미지수가 아핀 변환과 원근 변환의 중요한 차이점이 됨
  - 원근 변환 행렬 형태에서 확인할 수 있듯이 아핀 변환은 원근 변환의 하위 영역에 속함
  - 아핀 변환 행렬과 동일하게 $`x_{1}, y_{1}`$은 변환 전 원본 이미지의 픽셀 좌표, $`x_{2}, y_{2}`$는 변환 후의 결과 이미지의 픽셀 좌표
  - 변환 후의 픽셀 좌표를 계산하려면 미지수 $`a_{00}`$, $`a_{01}`$, $`a_{10}`$, $`a_{11}`$, $`a_{20}`$, $`a_{21}`$ $`b_{0}`$, $`b_{1}`$의 값을 알아야 함
    - 네 개의 좌표를 활용해 미지수 계산
- 원근 변환은 임의의 네 개의 점을 매핑해 기하학적 변환을 수행함
- 임의 위치인 A, B, C, D의 픽셀 좌표를 A', B', C', D'로 이동한 좌표를 **원근 맵 행렬(Perspective Transformation Matrix)** 로 계산해서 원근 변환 수행
  - 여덟 개의 미지수를 구하기 위해 네 개의 픽셀 좌표를 재매핑해서 원근 맵 행렬로 계산하는 것
- 원근 맵 행렬 생성 함수
  - C#

    ```csharp
    Cv2.WarpPerspective(
        Mat src,
        Mat dst,
        Mat M,
        Size dsize,
        InterpolationFlags flags = InterpolationFlags.Linear,
        BorderTypes borderMode = BorderTypes.Constant,
        Scalar? borderValue = null
    );
    ```

  - Python

    ```python
    dst = cv2.warpPerspective(
        src,
        M,
        dsize,
        dst=None,
        flags=None,
        borderMode=None,
        borderValue=None
    )
    ```

  - 아핀 변환 함수와 동일한 매개 변수를 가짐
  - **입력 이미지(`src`)** 에 **원근 맵 행렬(`M`)** 을 적용하고 **출력 이미지 크기(`dsize`)** 로 변형해 **출력 이미지(`dst`)** 반환
  - 이미지를 변형하기 때문에 **보간법(`flags`)** 과 **테두리 외삽(`borderMode`)** 설정
  - **테두리 색상(`borderValue`)**: 변환 후에 발생하는 공백의 공간에 할당할 색상

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-31/Program.cs#L1-L40

https://github.com/lemon-lime-honey/opencv-study/blob/af06bc5f9332171def30e5602649855703083a8c/05/ex5-32/Program.py#L1-L19
