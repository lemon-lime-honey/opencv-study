# 데이터 형식과 연산

## 01 기본 데이터

### 1. C# OpenCvSharp에서 사용되는 기본 데이터 형식

#### 벡터 구조체

- `Vec<요소의 개수><데이터 형식>`

| OpenCV 형식 | 요소의 개수 | 데이터 형식 | 의미 |
| --- | --- | --- | --- |
| `Vec2b` | 2 | byte | 2개의 요소를 지니는 byte 벡터 구조체 |
| `Vec2w` | 2 | ushort | 2개의 요소를 지니는 ushort 벡터 구조체 |
| `Vec2s` | 2 | short | 2개의 요소를 지니는 short 벡터 구조체 |
| `Vec3i` | 3 | int | 3개의 요소를 지니는 int 벡터 구조체 |
| `Vec4f` | 4 | float | 4개의 요소를 지니는 float 벡터 구조체 |
| `Vec6d` | 6 | double |  6개의 요소를 지니는 double 벡터 구조체 |

https://github.com/lemon-lime-honey/opencv-study/blame/48d854089ae6d7616f7ca18200c447bd54c2ee02/03/ex3-1/Program.cs#L10-L15

- 프리미티브 유형의 값을 저장하기 위한 구조체
- 두 개의 벡터 구조체가 같은 요소를 지니고 있는지 확인할 때 사용
- 벡터 데이터를 저장하고 [] 연산자를 사용해 접근할 때 사용
- `Item0`, `Item1`, ... 등의 멤버 변수를 사용해 벡터 구조체 요소에 직접 접근 가능
- `Equals` 메서드를 사용해 두 벡터 구조체가 일치하는지도 확인 가능

#### 포인트 구조체

- `Point<요소의 개수><데이터 형식>`

| OpenCV 형식 | 요소의 개수 | 데이터 형식 | 의미 |
| --- | --- | --- | --- |
| `Point` | 2 | int, double | 2개의 요소를 지니는 int, double 포인트 구조체 |
| `Point2f` | 2 | float | 2개의 요소를 지니는 float 포인트 구조체 |
| `Point2d` | 2 | double | 2개의 요소를 지니는 double 포인트 구조체 |
| `Point3f` | 3 | float | 3개의 요소를 지니는 float 포인트 구조체 |
| `Point3d` | 3 | double | 4개의 요소를 지니는 double 포인트 구조체 |

- 프리미티브 유형의 값을 저장하기 위한 구조체
- 2차원 또는 3차원 포인트를 나타내기 위한 제네릭 구조체
- 벡터 구조체와 상호 캐스팅 가능
- **오버헤드(Overhead)** 없음
- 포인트 구조체로는 좌표값의 벡터 계산을 쉽게 수행할 수 있음
- 포인트 구조체의 원소값에 접근할 때에는 X, Y, Z 멤버 사용
- 대괄호 연산자를 사용해 값에 접근할 수 없음
- 벡터 계산 시 소수점이 발생하는 경우 소수점 이하는 절사해 정수형 데이터로 반환
- C# OpenCvSharp에서는 2차원 포인트 구조체에 대해서만 벡터 연산 수행 가능
  - 3차원 포인트 구조체는 산술 연산자(+, -, *)와 비교 연산자(==, !=)만 지원

##### 포인트 구조체와 벡터 구조체의 상호 캐스팅

https://github.com/lemon-lime-honey/opencv-study/blame/48d854089ae6d7616f7ca18200c447bd54c2ee02/03/ex3-2/Program.cs#L10-L16

##### 포인트 구조체의 벡터 연산

https://github.com/lemon-lime-honey/opencv-study/blob/48d854089ae6d7616f7ca18200c447bd54c2ee02/03/ex3-3/Program.cs#L10-L19

#### 스칼라 구조체

- 벡터 구조체에서 파생된 4개의 요소를 가지는 제네릭 구조체
- 배정밀도 부동 소수점 형식을 멤버로 사용
- 벡터 구조체와 상호 캐스팅 연산 수행 불가
- OpenCV에서 픽셀 값을 전달하는 데 주로 사용
- 직접 값을 할당할 때 4개보다 적은 값을 입력하면 자동으로 0이 할당됨

| 연산 | 사용 예 | 반환값 예시 |
| --- | --- | --- |
| 모든 값 할당 | `Scalar.All(v)` | `[v, v, v, v]` |
| RGB 형식 변환 | `Scalar.FromRgb(r, g, b)` | `[b, g, r, 0]` |
| 무작위 색상 | `Scalar.RandomColor()` | `[94, 254, 248, 0]` |
| 요소별 곱셈 | `s1.mul(s2)` | `[22320, 2673, 0, 0]` |
| 켤레 | `s1.Conj()` | `[v, -v, -v, -v]` |
| 실수 확인 | `s1.isReal()` | 모든 값이 0일 경우 `True` 아닐 경우 `False` |
| 형식 변환 | `s1.ToVec3b()` | 벡터 구조체 `Vec3b` 형식으로 변환 |

https://github.com/lemon-lime-honey/opencv-study/blob/48d854089ae6d7616f7ca18200c447bd54c2ee02/03/ex3-4/Program.cs#L10-L16

- 이외에도 `Equals`, `GetType`, `ToString`과 같은 기본적인 메서드가 있음

#### 사이즈 구조체

- OpenCV 이미지 구성 요소 중 이미지 크기
- 너비와 높이를 멤버로 사용
- OpenCvSharp에서는 포인트 클래스와의 상호 캐스팅이 불가
  - C/C++에서는 가능
- `Mat` 클래스에서 사이즈 구조체를 메서드처럼 사용해 동일한 크기 바로 사용 가능

https://github.com/lemon-lime-honey/opencv-study/blob/48d854089ae6d7616f7ca18200c447bd54c2ee02/03/ex3-5/Program.cs#L10-L17

- 사이즈 구조체를 생성한 후 `Mat` 객체에 할당, `Width`와 `Height` 멤버를 통해 사용 가능
- `Mat` 클래스에서도 `Size` 메서드로 값에 접근 가능

#### 범위 구조체

- 어떤 시퀀스의 범위를 지정하는 데 사용
- 생성자 하나와 정적 메서드 하나만 포함됨
- `new Range(start, end)`의 형태로 시작 값부터 종료 값(미포함)까지의 범위 설정
- `Range.All`
  - 현재 개체가 선언된 범위 표시
  - 개체의 범위를 표시하거나 그대로 사용할 떄 이용

https://github.com/lemon-lime-honey/opencv-study/blob/48d854089ae6d7616f7ca18200c447bd54c2ee02/03/ex3-6/Program.cs#L10-L11

#### 직사각형 구조체

- 좌측 상단의 좌표를 의미하는 **포인트 구조체**, 너비와 높이를 의미하는 **사이즈 구조체** 사용
- **오버로드(overload)**된 생성자가 있어 `x, y, width, height`의 형태로 구조체 생성 가능

https://github.com/lemon-lime-honey/opencv-study/blob/48d854089ae6d7616f7ca18200c447bd54c2ee02/03/ex3-7/Program.cs#L10-L14

| 연산 | 사용 예 | 반환값 예시 |
| --- | --- | --- |
| 멤버 접근 | `rect.X`, `rect.Y`, `rect.Width`, `rect.Height` <br /> `rect.Left`, `rect.Right`, `rect.Top`, `rect.Bottom` | `int` 형식 |
| 멤버 접근 | `rect.TopLeft`, `rect.BottomRight` | `Point` 구조체 형식 |
| 좌측 상단 지점 | `rect.Location` | `Point` 구조체 형식 |
| 특정 위치가 직사각형 구조체 <br /> 내부에 있는지 여부 확인 | `rect.Contains(Point)` | `Boolean` 형식 |
| 두 직사각형 구조체의 영역 <br /> 합집합 | `rect1.Union(rect2)` | `Rect` 구조체 형식 |
| 두 직사각형 구조체의 영역 <br /> 교집합 | `rect1.Intersect(rect2)` | `Rect` 구조체 형식 |
| 직사각형 구조체 팽창 | `rect.Inflate(Size)` | `rect`에 직접 접근해서 변형 |

- `rect1`과 `rect2`에 대해 합집합 연산 수행 :arrow_right: 두 직사각형을 포함할 수 있는 최소 경계 사각형
- 아래는 직사각형 구조체를 이용한 연산의 예

| 연산 | 예제 |
| --- | --- |
| 직사각형을 `Point`만큼 이동 | `Rect = Rect + Point` <br /> `Rect += Point` <br /> `Rect = Rect - Point` <br /> `Rect -= Point` |
| 직사각형을 `Size`만큼 확대 | `Rect = Rect + Size` <br /> `Rect += Sz` |
| 직사각형을 `Size`만큼 축소 | `Rect = Rect - Size` <br /> `Rect -= Sz` |
| 두 직사각형 구조체의 영역 합집합 | `Rect = rect1 \| rect2` <br /> `rect1 \|= rect2` |
| 두 직사각형 구조체의 영역 교집합 | `Rect = rect1 & rect2` <br /> `rect1 &= rect2` |
| 두 직사각형 구조체의 상등 비교 | `bool = rect1 == rect2` |
| 두 직사각형 구조체의 부등 비교 | `bool = rect1 != rect2` |

#### 회전 직사각형 구조체

- `중심점`, `크기`, `각도`를 멤버로 사용
- 중심점을 기준으로 사각형 크기를 가지는 직사각형을 설정한 각도로 회전
- 생성할 때 `Point2f`, `Size2f`, `float`를 받음

https://github.com/lemon-lime-honey/opencv-study/blob/48d854089ae6d7616f7ca18200c447bd54c2ee02/03/ex3-8/Program.cs#L10-L14

| 연산 | 사용 예 | 반환값 예시 |
| --- | --- | --- |
| 멤버에 접근 | `rotatedRect.Center` <br /> `rotatedRect.Size` <br /> `rotatedRect.Angle` | `Point2f` 구조체 <br /> `Size2f` 구조체 <br /> `float` 형식 |
| 회전된 직사각형을 포함하는 직사각형 | `rotatedRect.BoundingRect()` | `Rect` 구조체 |
| 회전된 직사각형의 4개의 코너 | `rotatedRect.Points()` | `Point2f[]` 구조체 배열 |

### 2. 파이썬 OpenCV에서 사용되는 기본 데이터 형식

#### 리스트 자료형

- **컨테이너(Container)**
  - 데이터의 종류와 상관없이 여거 값을 저장할 수 있는 컨테이너
  - 서로 다른 데이터 형식인 정수, 문자열, 부동소수점 등을 모두 리스트에 저장할 수 있음
  - **가변성(Mutable)**
    - 변경 가능한 자료형
    - 리스트 요소 생성, 추가, 삭제 및 변경 가능
  - **시퀀스(Sequence)**
    - 순서를 중요하게 다루는 자료형
    - 내부 항목은 정의된 순서대로 저장
    - 각 항목은 색인(index)을 통해 접근 가능: 리스트 항목에 접근하거나 변경하는 데 사용
- Python OpenCV를 사용할 때 주로 사용하는 데이터 형식은 NumPy 배열
  - 데이터를 처리하면서 리스트 형식의 데이터가 필요한 경우가 많음

https://github.com/lemon-lime-honey/opencv-study/blob/48d854089ae6d7616f7ca18200c447bd54c2ee02/03/ex3-9/Program.py#L5-L11

- `cv2.threshold`
  - 이진화 처리
  - NumPy 배열(`src`), 상수(100, 255), 임계값 유형(`dsize`) 등을 매개 변수로 전달

#### 튜플 자료형

- 컨테이너, **불변성(Immutable)**, 시퀀스
- Python OpenCV에서는 매개 변수의 형식이 튜플이어야 하는 경우도 있음

https://github.com/lemon-lime-honey/opencv-study/blob/48d854089ae6d7616f7ca18200c447bd54c2ee02/03/ex3-10/Program.py#L5-L8

- `cv2.circle()` 함수의 중심점을 나타내는 매개 변수는 튜플이어야 함
- 값이 변경되는 데이터여도 일부 함수에서는 매개 변수로 튜플을 전달해야 함

#### 사전 자료형

- 키(key), 값(value)로 이루어진 자료형
- **컨테이너**, **가변성**, **매핑(Mapping)**
- 매핑: 순서를 고려하지 않는 자료형
- 키는 중복될 수 없으나 값은 중복될 수 있음
- 일부 함수에서는 매개 변수로 사전을 전달해야 함

https://github.com/lemon-lime-honey/opencv-study/blob/48d854089ae6d7616f7ca18200c447bd54c2ee02/03/ex3-11/Program.py#L5-L11

#### 집합 자료형

- 집합 연산을 간편하게 처리하기 위해 사용하는 자료형
- **컨테이너**, **가변성**, **집합(Set)**
- 중복 불허, 순서에 영향을 받지 않음
- 리스트로 변환하면 값에 접근은 가능하나 순서가 보장되지 않음
- 이미지 처리의 전처리나 후처리 과정에서 값의 중복을 제거하기 위한 필터로 활용 가능

https://github.com/lemon-lime-honey/opencv-study/blob/48d854089ae6d7616f7ca18200c447bd54c2ee02/03/ex3-12/Program.py#L1-L10

## 02 Mat 데이터

- 행렬이나 배열을 저장하기 위한 데이터 형식으로 사용
  - **행렬(Matrix)**
    - 기본적으로 2차원 배열
    - 행과 열로 구성된 데이터 구조
  - **배열(Array)**
    - 더 일반적인 데이터 구조
    - 1차원, 2차원, 3차원을 비롯해 그 이상의 차원을 가질 수 있음
    - 데이터의 순서나 구조를 나타내는 데 사용
- `Mat 클래스`: 헤더와 데이터 포인터로 구성됨
  - **헤더(Header)**
    - `Mat` 클래스에 대한 정보가 담겨 있음
    - 행렬(배열)의 크기, 데이터 형식, 차원, `Mat` 클래스에 관한 메타데이터
    - 메모리 주소가 아닌 데이터의 구조 및 특성에 대한 메타 정보 제공
  - **데이터 포인터(Data pointer)**
    - 행렬(배열)의 데이터가 담긴 메모리 주소 정보가 담겨 있음
    - 데이터 포인터를 통해 실제 데이터에 접근하고 조작할 수 있음
- OpenCvSharp에서 제공하는 대부분의 함수는 인수나 반환값으로 `Mat` 클래스 사용

### 1. 조밀 행렬

- **조밀(Dense)**
  - 배열의 모든 요소가 의미 있는 값으로 채워짐
  - 0이 아닌 값이 하나라도 존재하면 메모리 공간 할당
  - 배열의 모든 요소에 대해 메모리가 확보되어 있음
  - 빈 요소를 저장하기 위한 메모리는 할당되지 않음
- **래스터 주사(Raster scan)**
  - 행렬 상단부터 시작해 수평 주사선을 한 줄씩 아래로 내려가며 데이터를 순차적으로 저장하고 읽어오는 방식
  - 행렬 상단에서 시작, 왼쪽 상당에서 오른쪽 상단, 다음 행
- `Mat` 클래스는 래스터 주사 순서에 따라 배열 요소 저장

#### 메모리 레이아웃

- `M.Step[]` 배열에 의해 정의됨
- 요소에 대한 주소는 $i_{0}$, $i_{1}$, ... , $i_{M.dims-1}$ 순서로 배치됨
  - 수식 3.1: 데이터 메모리 레이아웃(일반형)  
    $ \text{address}\left(M_{i_{0}, i_{1}, ..., i_{M.dims-1}}\right) = M.data + M.step\left[0\right] \times i_{0} + M.step\left[1\right] \times i_{1} + ... $  
    $+ M.step\left[M.dims-1\right] \times i_{M.dims-1}$
  - 수식 3.2: 데이터 메모리 레이아웃(2차원 배열)
    $ \text{address}\left(M_{i_{0}, i_{1}}\right) = M.data + M.step\left[0\right] \times i_{0} + M.step\left[1\right] \times i_{1} $
- 2차원 배열은 행 단위로, 3차원 배열은 평면 단위로 저장
- **배열 요소의 크기(Byte)** 의 크기는 `M.ElemSize` 메서드를 사용해 확인 가능
- 배열 `M`에 저장된 데이터가...
  - 단일 데이터인 경우, 해당 배열은 `N`차원 단일 채널 배열로 간주됨
  - 다중 데이터인 경우, 해당 배열은 `N-1` 차원 다중 채널 배열로 간주됨
- 배열 요소의 크기를 통해 메모리에 할당된 크기 판단 가능
  - 2차원 배열인 `CV_8UC1`
    - 8비트 정수형으로 이루어진 단ㄴ일 채널 2차원 배열
    - 1바이트의 요소가 한 개의 채널을 구성하고 있으므로 크기는 1바이트
  - 2차원 배열인 `CV_64C3`
    - 64비트 부동 소수점으로 이루어진 다중 채널 이미지
    - 이 이미지의 2차원 배열의 요소 크기: 24바이트

#### 객체 생성

- `Mat` 클래스는 인스턴스를 초기화하는 순간 행렬이 생성됨
- 기본 생성자의 경우 행렬 크기와 데이터 형식을 인자로 받지 않음
  - `Mat` 클래스의 `Create` 메서드를 통해 동적으로 행렬에 데이터를 할당할 수 있음
  - `Create`는 오버로드된 메서드 제공
    - 행과 열의 수와 행렬의 데이터 타입을 매개 변수로 받음

| 메서드 | 설명 |
| --- | --- |
| `Create(MatType type, params int[] sizes)` | `int` 배열을 통한 행렬 크기 입력 |
| `Create(Size size, MatType type)` | `Size` 구조체를 통한 행렬 크기 입력 |
| `Create(int rows, int cols, MatType type)` | 행과 열을 통한 행렬 크기 입력 |

- 데이터 형식에 따라 행렬 요소의 형식이 결정되고 `SetTo` 메서드로 행렬 값 할당 가능

https://github.com/lemon-lime-honey/opencv-study/blob/48d854089ae6d7616f7ca18200c447bd54c2ee02/03/ex3-13/Program.cs#L10-L16

- `Create` 메서드로 `Mat` 객체의 값을 할당할 수 있지만 `Mat`은 생성자가 여러 개로 오버로드 되어 있음

<br />

- `Mat` 클래스에서 데이터를 복사하지 않는 생성자 목록

| 생성자 | 설명 |
| --- | --- |
| `Mat()` | 기본 생성자 |
| `Mat(int rows, int cols, MatType type)` | 지정된 `type`의 행렬 |
| `Mat(int rows, int cols, MatType type, Scalar s)` | 초기화 값을 갖는 지정된 `type`의 행렬 |
| `Mat(Size size, MatType type)` | 지정된 `type`의 행렬 |
| `Mat(Size size, MatType type, Scalar s)` | 초기화 값을 갖는 지정된 `type`의 행렬 |
| `Mat(` <br /> `    int rows, int cols, MatType type,` <br /> `    IntPtr data, long step = 0` <br /> `)` | 사용자 `data`의 포인터와 지정된 `type`의 행렬 |
| `Mat(` <br /> `    int rows, int cols, MatType type,` <br /> `    Array data, long step = 0` <br /> `)` | 사용자 `data`의 포인터와 지정된 `type`의 행렬 |

- `Mat` 클래스는 스칼라 구조체를 이용해 행렬 전체의 초기값을 할당할 수 있음
- 사용자 데이터 포인터를 통해 행렬을 생성하는 경우
  - 지정된 데이터를 가리키는 행렬의 헤더 정보 초기화
  - 외부 데이터는 자동으로 할당 해제 되지 않음
- 생성자의 `step` 매개 변수: 행렬의 행이 차지하는 바이트 수
  - 값의 행 끝에 **바이트 패딩(Byte Padding)`이 존재한다면 포함해야 함
  - `step` 매개 변수가 `0`이라면 바이트 패딩이 없는 것으로 간주
    - `cols x ElemSize`로 계산됨

<br />

- 열거자를 사용하는 생성자 목록

| 생성자 | 설명 |
| --- | --- |
| `Mat(` <br /> `    IEnumerable<int> sizes,` <br /> `    MatType type` <br /> `)` | 지정된 `type`의 N차원 배열 |
| `Mat(` <br /> `    IEnumerable<int> sizes,` <br /> `    MatType type,` <br /> `    Scalar s` <br /> `)` | 초기화 값을 갖는 지정된 `type`의 N차원 배열 |
| `Mat(` <br /> `    IEnumerable<int> sizes,` <br /> `    MatType type,` <br /> `    IntPtr data,` <br /> `    IEnumerable<long> steps = null` <br /> `)` | 사용자 `data`의 포인터와 지정된 `type`의 N차원 배열 |
| `Mat(` <br /> `    IEnumerable<int> sizes,` <br /> `    MatType type,` <br /> `    Array data,` <br /> `    IEnumerable<long> steps = null` <br /> `)` | 사용자 `data`의 포인터와 지정된 `type`의 N차원 배열 |

- N차원 배열 생성 가능
- 리스트 형식으로 인덱싱할 수 있는 컬렉션으로 인스턴스 초기화

https://github.com/lemon-lime-honey/opencv-study/blob/48d854089ae6d7616f7ca18200c447bd54c2ee02/03/ex3-14/Program.cs#L11-L12

- 데이터를 복사하는 생성자 목록

| 생성자 | 설명 |
| --- | --- |
| `Mat(IntPtr ptr)` | 네이티브 포인터를 이용한 복사 |
| `Mat(Mat m, Rect roi)` | 관심 영역으로 지정된 행과 열을 복사 |
| `Mat(Mat m, params Range[] ranges)` | 행과 열의 영역을 복사 |
| `Mat(` <br /> `    string filename,` <br /> `    ImreadModes flags = ImreadModes.Color` <br /> `)` | 파일에서 이미지를 불러옴 |

- C#에서는 안전성 및 보안을 유지하기 위해 기본적으로 포인터 산술 연산을 지원하지 않음
  - `IntPtr`로 비 포인터 유형에 포인터 값을 저장해 안전한 데이터 형식으로 저장 후 사용
  - 그 후 `CvPtr` 속성으로 `Mat` 클래스의 네이티브 포인터를 호출해 복사 가능

<br />

- `Mat` 클래스에서 특정 영역만 복사해서 저장할 수 있음
  - 행과 열의 범위를 지정해 특정 영역 저장
  - 이 부분 영역을 관심 영역이라 함
- 위 표의 마지막 생성자
  - 유일하게 프로그램 외부에서 데이터를 받아옴
  - 파일 경로(`fileName`)에서 이미지를 불러와 `Mat` 객체에 저장
  - 행과 열을 지정하거나 이미지를 불러오는 방법은 행렬에서만 작동

#### 행렬 표현식

- `MatExpr`: 행렬 표현식을 사용할 수 있도록 제공됨
  - 행렬, 스칼라, 실수 등 복잡한 표현식에 대해 간단히 연산 가능
- `Mat` 클래스에서는 행렬 표현식을 사용할 수 있도록 정적 메서드 제공
  - 정적 메서드의 반환 형식은 `MatExpr`. `MatExpr` 클래스로 객체를 생성해도 `Mat`으로 변환됨
  - 행렬의 사칙연산, 역행렬, 전치 행렬 등을 간단히 처리 가능
  - 자주 사용되는 행렬(모든 요소가 0이나 1로 채워진 행렬과 단위행렬)을 만들 수 있는 메서드 존재

(표 3.11)

- `MatExpr`: 단일 채널에 대해서만 값 할당됨
- 대각 행렬을 제외한 메서드: 사이즈 구조체, `int` 배열을 통해서도 메서드 사용 가능
- 대각 행렬은 `Mat` 클래스만을 매개 변수로 사용해 생성
  - `Mat` 형식인 `d`는 단일 행 또는 단일 열로 구성된 행렬
  - 단일 행이나 단일 열로 구성된 행렬을 매개 변수로 사용할 경우 `mxm` 크기의 대각 행렬 생성
  - `Diag` 메서드는 `O(1)` 연산

#### 개별 단위 요소에 접근하기

- `Mat` 클래스에 담긴 데이터의 정보를 확인하기 위해 `Mat` 클래스를 직접 출력하면 행렬의 헤더 정보 반환

##### `At` 메서드

- 다양한 형식을 지원할 수 있도록 구성됨
- 지정한 행, 열, 차원에 해당하는 요소에 접근
- `Get` 메서드
  - `At` 메서드와 동일한 구조
  - cf) `Set` 메서드
    - 지정 요소의 값을 설정하는 데 사용
    - `value`의 값을 `type`과 일치시켜야 함

https://github.com/lemon-lime-honey/opencv-study/blob/e3f935d348c33e8d8f4a6c91f142a773174652d5/03/ex3-15/Program.cs#L10-L17

(표 3.12)

#### 마샬링

- 관리 코드와 비관리 코드 간에 데이터를 교차해야 하는 경우 형식을 변환하는 프로세스
- 포인터 사용 :arrow_right: C#에서는 권장하지 않음 :arrow_right: 마샬링
- `IntPtr` 형식의 데이터를 가져와 마샬링을 통해 포인터 형식 사용 가능
- `Mat` 클래스에서는 `Ptr` 메서드로...
  - 특정 행렬의 행에 접근 가능, 포인터 반환 가능
  - 배열을 구성하는 기본 타입에 대한 포인터 반환 가능
- 소스코드에 `using System.Runtime.InteropServices` 구문 추가
- 데이터 포인터에는 행렬의 데이터가 담겨있으므로 배열 요소에 가장 빠르게 접근 가능

https://github.com/lemon-lime-honey/opencv-study/blob/e3f935d348c33e8d8f4a6c91f142a773174652d5/03/ex3-16/Program.cs#L11-L22

- `Marshal.ReadByte` 정적 메서드를 활용해 지정된 오프셋 위치의 데이터를 읽음
- `offset` 설정 기준
  - `MatType`에 따라 달라짐
  - `MatType`에 따라 직접 주소를 계산해서 데이터 포인터에 접근
  - 2차원 이상과 다중 채널 배열을 처리하는 경우 매우 효율적
- 수식 3.3 오프셋 계산 방식<br />
  $ \text{offset}=\text{Step} \times \text{Row} + \text{ElemSize} \times \text{Col} $
  - 현재 포인터가 가리키는 곳을 `offset`으로 계산해서 데이터를 가져오는 방식
  - `Step` 메서드는 **정규화된 단계 반환**
- 수식 3.4 `Step` 메서드와 `Step1` 메서드의 계산 방식
  - $ \text{Step} = \text{ElemSize} \times \text{Cols} $
  - $ \text{Step1} = \dfrac{\text{ElemSize}}{\text{ElemSize1}} \times \text{Cols}$
  - `ElemSize`
    - 배열 요소의 크기(바이트)
    - `Mat` 클래스의 **바이트 크기** $ \times $ **채널 수**
  - `ElemSize1`: 단일 공간(하위 요소)의 크기
- `Step` 메서드는 정규화된 단계를 계산할 때 `ElemSize`와 열의 수 사용
  - 더 간단하게 정규화된 단계를 계산하므로 임의의 행렬 요소에 빠르게 접근 가능
- `m.Ptr(0)`
  - 첫 번째 행의 포인터를 가져옴
  - 첫 번째 행의 포인터 값에서 계산된 오프셋만큼 포인터의 위치를 변경시키며 지정된 행과 열 위치의 값 가져옴
  - 다중 채널: 채널 수만큼 더해 특정 채널의 값을 가져올 수 있음
  - 중간에 `MatType`이 바뀌더라도 `offset`을 통해 메모리 주소 계산 :arrow_right: 유동적으로 사용 가능
- 마샬 클래스
  - `Marshal.ReadByte` 외에도 `ReadInt16`, `ReadInt32` 등 지원
  - `Mat` 클래스의 다차원 배열이나 다중 채널 배열에 대해 요소 별로 이뤄지는 작업을 수행할 때 간편히 사용
  - 이미지에도 마샬링 적용 가능 :arrow_right: 픽셀에 접근해 값을 변경하거나 할당할 때 유용히 활용 가능
  - `Marshal.Read*` 메서드: 반환 데이터 `Byte` / `Int` :arrow_right: `MatIndexer` 클래스 제공
  - `MatIndexer` 클래스를 통해 손쉽게 데이터를 가져오거나 값 할당 가능

https://github.com/lemon-lime-honey/opencv-study/blob/e3f935d348c33e8d8f4a6c91f142a773174652d5/03/ex3-17/Program.cs#L10-L24

- `MatIndexer` 클래스
  - `Mat` 클래스에서 행렬 요소에 빠르게 접근하기 위한 기능 제공
  - 행렬 요소에 대한 계산을 마샬링 없이 수행 가능
  - 행렬의 요소에 빠르게 접근해 데이터를 읽거나 쓸 수 있는 방법
  - 주로 대량의 데이터를 처리하는 경우 유용
  - `MatIndexer` 클래스 내부에서 행렬 요소에 접근할 때 데이터에 대한 주소 계산 자동 처리
    1. `Mat<Vec3f>`로 `Vec3f` 형식의 `Mat` 클래스 생성
    2. 생성된 `mv3f` 변수에서 `GetIndexer` 메서드를 통해 `MatIndexer` 인스턴스 생성
    3. 생성된 `MatIndexer`는 배열에 접근하는 방법처럼 값을 할당하거나 불러올 수 있음
  - `GetGenericIndexer` 메서드
    - `Mat<T>` 변환과 `GetIndexer` 메서드를 합한 메서드
    - 제네릭 구조이므로 `Mat` 클래스를 변환하지 않아도 사용 가능

#### 블록 단위 요소에 접근하기

- 대규모 데이터 처리나 이미지 처리에서 유용

(표 3.13)

- `Row`와 `Col` 메서드 반환 값: `Mat` 클래스 형식
  - 특정 행이나 열에 대해 행렬 헤더 생성
  - 데이터 포인터와 `step` 배열 등 원본 배열을 가리킴
  - 새롭게 `Mat` 클래스를 생성해 `Set`을 통해 값 변경 :arrow_right: 원본 배열 값도 변경
  - 행렬 헤더만 생성되었을 뿐 새로운 데이터 포인터를 생성하지 않아 원본과 새 배열이 연결됨
- 범위 구조체(`RowRange`, `ColRange`)를 사용하면 배열 형태로 추출 가능
  - 사용 방식은 기능적으로 `Get` 메서드와 동일
- `Diag` 메서드: `m` 행렬의 대각 선분의 요소 값 반환
  - `MatDiagType`: 오프셋 설정값
    - `MatDiagType.Upper`: 대각선에서 위쪽 방향으로 1만큼 오프셋
    - `MatDiagType.Lower`: 대각선에서 아래쪽 방향으로 1만큼 오프셋
  - 대각 성분의 색인을 형성하므로 단행 열 행렬(`mx1` 형태)로 반환
- 인덱서를 사용해 배열의 하위 행렬의 형태로 접근하는 방식
  - 직사각형 구조체를 생성해 하위 행렬 지정
  - 범위 구조체나 직접 행과 열에 해당하는 부분을 할당해 특정 하위 배열의 요소에 간편히 접근

#### 행렬 연산

- 내부적으로 `MatExpr` 형식(행렬 표현식)으로 변환되어 처리됨
- 연산이 끝난 후 연산의 결과는 `Mat` 형식으로 반환
- 행렬 표현식 중 `=` 연산자는 데이터 포인터를 생성 또는 참조
  - 생성: 별도의 데이터로 간주해 메모리 할당
  - 참조: 같은 행렬로 간주
  - 예시
    - `m0 = m1`
      - `m0`이 `m1`을 참조
      - `m0`를 변경하면 `m1`도 변경 :arrow_right: 복제하려면 별도의 메서드 사용
    - `m0 = m1 + 1`
      - `m1`에 `1`을 더한 결과를 `m0`에 할당
      - `m1 + 1`은 행렬 표현식이 되어 `m0`에 데이터 포인터가 새로 할당됨
      - `m0`는 `m1`을 참조하지 않게 됨
      - 이 연산은 임시 행렬을 생성하고 그 결과를 `m0`에 복사함
      - 임시 행렬이 필요 없게 되면 자동으로 해제
- 연산자 오버로딩과 행렬 표현식을 사용하면 행렬 연산을 효과적으로 수행할 수 있음
- 메모리 관리도 내부적으로 처리되므로 사용자가 직접 관리할 필요가 없음

(표 3.14)

- C# OpenCvSharp에서는 `Mat` 클래스 간의 연산 뿐만 아니라 싱글턴 연산도 지원함
  - 싱글턴 연산은 스칼라 구조체와 숫자 형식에 적용됨
  - 숫자 간의 비트 연산이나 다른 수학적 연산을 `Mat` 클래스와 형변환 없이 쉽게 수행 가능

(표 3.15)

- 요소별 콥센(`Mul`) 메서드를 사용할 때 값 범위가 `MatType`의 표현 제한을 벗어날 수 있음
  - 비율(`scale`)을 조정해 결과값을 낮춘다.
- 역행렬(`Inv`) 메서드
  - 행렬 역변환을 수행하기 위해 여러 알고리즘 지원
  - 다양한 분해 방법 선택 가능 :arrow_right: 분해 방법에 따라 다른 결과
    - LU 분해(`DecompTypes.LU`)
    - 특이값 분해(`DecompTypes.SVD`)
    - 고유값 분해(`DecompTypes.Eig`)
    - 숄레스키 분해(`DecompTypes.Cholesky`)
    - QR 인수 분해(`DecompTypes.QR`)
    - 노멀 분해(DecompTypes.Normal`)
- 외적(`Cross`) 메서드
  - 특정 조건을 충족할 때에만 사용 가능
  - 행, 열, 채널의 곱이 3일 때 외적 수행 가능
- 요소별 비교
  - OpenCvSharp에서는 메서드를 이용해 행렬의 요소별 비교 수행
  - 요소가 참인 경우 255, 거짓인 경우 0 반환

#### 그 밖의 행렬 메서드

(표 3.16)

### 2. 희소 행렬
